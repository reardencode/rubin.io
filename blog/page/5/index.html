<!DOCTYPE html>
<html lang="en-us">
    <head>
  <title> Blog (page 5) &middot; Jeremy Rubin </title>
  <link href="https://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">

  <!-- Enable responsiveness on mobile devices-->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">


  <!-- CSS -->
  <link rel="stylesheet" href="/public/css/poole.css">
  <link rel="stylesheet" href="/public/css/syntax.css">
  <link rel="stylesheet" href="/public/css/hyde.css">
  <link rel="stylesheet" href="/public/font-awesome-4.5.0/css/font-awesome.min.css">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=PT+Sans:400,400italic,700|Abril+Fatface">
  <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>

  <!-- Icons -->
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/public/apple-touch-icon-144-precomposed.png">
                                 <link rel="shortcut icon" href="/public/favicon.ico">

  <!-- RSS -->
  <link rel="alternate" type="application/rss+xml" title="RSS" href="/atom.xml">

  
  <link type="application/atom+xml" rel="alternate" href="http://rubin.io/feed.xml" title="Jeremy Rubin" />


  <!-- GA -->
<script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
    ga('create', 'UA-40376251-1', 'auto');
    ga('send', 'pageview');
</script>

  
  <link rel="me" href="https://twitter.com/JeremyRubin" >
  <meta name="twitter:dnt" content="on">
			   <script>window.twttr = (function(d, s, id) {
  var js, fjs = d.getElementsByTagName(s)[0],
    t = window.twttr || {};
  if (d.getElementById(id)) return t;
  js = d.createElement(s);
  js.id = id;
  js.src = "https://platform.twitter.com/widgets.js";
  fjs.parentNode.insertBefore(js, fjs);

  t._e = [];
  t.ready = function(f) {
    t._e.push(f);
  };

  return t;
}(document, "script", "twitter-wjs"));</script>

</head>

    <body>
        <div class="sidebar">
    <h3 style="text-align: center;"> <a href="/"> Jeremy Rubin </a> </h3>
    <div class="container">
        <div class="sidebar-about">

            <div class="sidebar-about-info"> 
                <a href="/public/pdfs/resume.pdf"><i class="fa fa-file-text-o" title=Resume></i></a>
                <a href=""><i class="fa fa-github" title=Github></i></a>
                <a href="https://twitter.com/JeremyRubin"><i class="fa fa-twitter" title=Twitter></i></a>
            </div>
            <div class="sidebar-about-info hide-large">
                <a class="" href="/">Home</a>
                <a class="" href="/blog/">Blog</a>
                <a class="" href="/talks/">Talks</a> 
                <a class="" href="/projects/">Projects</a>
                <a class="" href="/archive/">Site Index</a>
            </div>
        </div>




        <nav class="sidebar-nav hide-small">
            <a class="sidebar-nav-item" href="/">Home</a>
            <a class="sidebar-nav-item" href="/blog/">Blog</a>
            <a class="sidebar-nav-item" href="/talks/">Talks</a> 
            <a class="sidebar-nav-item" href="/projects/">Projects</a>
            <a class="sidebar-nav-item" href="/archive/">Site Index</a>
        </nav>
    </div>
</div>



        <div class="content container" style="padding-bottom:0;">
            <div class="page">
    
    
    <h1>
  Jeremy Rubin's Blog
</h1>

Here you'll find an assorted mix of content from yours truly. I post about a lot
of things, but primarily <a href="/bitcoin/">Bitcoin</a>.

<p>
categories: <a href="/bitcoin/">Bitcoin</a>, <a href="/shenzhen/">Shenzhen Journey</a>.
</p>
<div class="posts">
  
<hr>
  <div class="post">
    <h2 class="post-title">
        <a href="/bitcoin/2021/12/10/advent-13/">
        Payment Pools / Coin Pools
      </a>
  </h2>
  <h4>Day 13: Rubin's Bitcoin Advent Calendar</h4>


    <span class="post-date">10 Dec 2021</span>

    <p><em>Welcome to day 13 of my Bitcoin Advent Calendar. You can see an index of all
the posts <a href="/advent21">here</a> or subscribe at
<a href="https://judica.org/join">judica.org/join</a> to get new posts in your inbox</em></p>

<p>Payment Pools are a general concept for a technique to share a single UTXO among
a group. They’ve been discussed for a couple years<sup id="fnref:background" role="doc-noteref"><a href="#fn:background" class="footnote" rel="footnote">1</a></sup>, but now that
Taproot is active are definitely more relevant! In this post we’ll go through
some really simple Payment Pool designs before turning it up a little bit :)</p>

<p>Mechanistically, all that is required of a Payment Pool is that:</p>

<ol>
  <li>It’s a single (shared) UTXO<sup id="fnref:single" role="doc-noteref"><a href="#fn:single" class="footnote" rel="footnote">2</a></sup></li>
  <li>Every user can get their funds out unilaterally<sup id="fnref:implies" role="doc-noteref"><a href="#fn:implies" class="footnote" rel="footnote">3</a></sup></li>
  <li>A set<sup id="fnref:unan" role="doc-noteref"><a href="#fn:unan" class="footnote" rel="footnote">4</a></sup> of users can authorize spend the funds</li>
  <li>Unspent funds/change stays in the pool</li>
</ol>

<h2 id="why-pool">Why Pool?</h2>

<p>Pools are really great for a number of reasons. In particular, Payment Pools are
fantastic for Scalability since they mean 1 utxo can serve many masters, and
also each txn only requires one signature to make a batched payment from a
group. Payment Pools are kinda a killer version of a coin-join where you roll
the funds from coinjoin to coinjoin automatically<sup id="fnref:greg" role="doc-noteref"><a href="#fn:greg" class="footnote" rel="footnote">5</a></sup>, giving you great privacy.
We’ll also see how they benefit decentralization in a couple of days.</p>

<h2 id="whats-the-simplest-design-that-can-satisfy-this">What’s the simplest design that can satisfy this?</h2>

<p>Imagine a coin that is either N-of-N multisig OR a transaction distributing the
coins to all users. The Sapio would look a bit like this:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">SimplePool</span> <span class="p">{</span>
    <span class="c">/// list of all initial balances</span>
    <span class="n">members</span><span class="p">:</span> <span class="n">HashMap</span><span class="o">&lt;</span><span class="n">PublicKey</span><span class="p">,</span> <span class="n">Amount</span><span class="o">&gt;</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">SimplePool</span> <span class="p">{</span>
    <span class="c">/// Send their balances to everyone</span>
    <span class="nd">#[then]</span>
    <span class="k">fn</span> <span class="nf">ejection</span><span class="p">(</span><span class="k">self</span><span class="p">,</span> <span class="n">ctx</span><span class="p">:</span> <span class="n">Context</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">t</span> <span class="o">=</span> <span class="n">ctx</span><span class="nf">.template</span><span class="p">();</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">amount</span><span class="p">)</span> <span class="n">in</span> <span class="k">self</span><span class="py">.members</span><span class="nf">.iter</span><span class="p">()</span> <span class="p">{</span>
            <span class="n">t</span> <span class="o">=</span> <span class="n">t</span><span class="nf">.add_output</span><span class="p">(</span><span class="n">amt</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key</span><span class="p">,</span> <span class="nb">None</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">t</span><span class="nf">.into</span><span class="p">()</span>
    <span class="p">}</span>

    <span class="c">/// all signed the transaction!</span>
    <span class="nd">#[guard]</span>
    <span class="k">fn</span> <span class="nf">all_signed</span><span class="p">(</span><span class="k">self</span><span class="p">,</span> <span class="n">ctx</span><span class="p">:</span> <span class="n">Context</span><span class="p">)</span> <span class="p">{</span>
        <span class="nn">Clause</span><span class="p">::</span><span class="nf">Threshold</span><span class="p">(</span><span class="k">self</span><span class="py">.members</span><span class="nf">.len</span><span class="p">(),</span>
                          <span class="k">self</span><span class="py">.members</span>
                              <span class="nf">.keys</span><span class="p">()</span>
                              <span class="nf">.map</span><span class="p">(</span><span class="nn">Clause</span><span class="p">::</span><span class="n">Key</span><span class="p">)</span>
                              <span class="nf">.collect</span><span class="p">())</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">Contract</span> <span class="k">for</span> <span class="n">SimplePool</span> <span class="p">{</span>
    <span class="nd">declare!</span><span class="p">{</span><span class="n">then</span><span class="p">,</span> <span class="nn">Self</span><span class="p">::</span><span class="n">ejection</span><span class="p">}</span>
    <span class="nd">declare!</span><span class="p">{</span><span class="n">finish</span><span class="p">,</span> <span class="nn">Self</span><span class="p">::</span><span class="n">all_signed</span><span class="p">}</span>
<span class="p">}</span>

</code></pre></div></div>
<p>Let’s check our list:</p>

<ol>
  <li>It’s a single UTXO – Check</li>
  <li>Every user can get their funds out unilaterally – Check, with SimplePool::ejection</li>
  <li>A set of users can authorize spend the funds – Check, unanimously</li>
  <li>Unspent funds/change stay in the pool – We’ll give this a Check, just don’t sign transaction that don’t meet this contstraint.</li>
</ol>

<p>So we’re good! This is all we need.</p>

<h2 id="but-is-it-really-all-we-need">But is it really all we need?</h2>

<p>It’d be nice if the Payment Pool had a little bit more structure around the
updating so that a little bit less was left to the user to do correctly.
Luckily, Sapio has tools for that. Let’s define a transition function in Sapio
that generates what we should do with <code class="language-plaintext highlighter-rouge">Simple::all_signed</code>.</p>

<p>The transition function should take a list of signed updates per participant and
generate a transaction for signing (signing the inputs helps with coordinating
not signing the incorrect transaction). Any leftover funds should be sent into a
new instance of the Payment Pool for future use.</p>

<p>We’ll also make one more change for efficient ejections: In the version I gave
above, the unilateral ejection option exits everyone out of the pool, which
kinda sucks.</p>

<p>However, we will ‘hybridize’ the payment pool with the tree payment.  Then, you
would have “hierarchical” pools whereby splitting would keep pools alive. E.g.,
if you had 30 people in a pool with a splitting radix of 2, 1 person
force-ejecting themselves would create something like 1 pool of size 15, 1 pool
of size 7, 1 pool of size 4, 1 pool of size 2, and 2 ejected people. They can
always re-join a pool again after!</p>

<p>First, we’ll define the basic Pool data and interface:</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">#[derive(Deserialize,</span> <span class="nd">JsonSchema,</span> <span class="nd">Clone)]</span>
<span class="k">struct</span> <span class="n">NextTxPool</span> <span class="p">{</span>
    <span class="c">/// map of all initial balances as PK to BTC</span>
    <span class="n">members</span><span class="p">:</span> <span class="n">BTreeMap</span><span class="o">&lt;</span><span class="n">PublicKey</span><span class="p">,</span> <span class="n">AmountF64</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="c">/// The current sequence number (for authenticating state updates)</span>
    <span class="n">sequence</span><span class="p">:</span> <span class="nb">u64</span><span class="p">,</span>
    <span class="c">/// If to require signatures or not (debugging, should be true)</span>
    <span class="n">sig_needed</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">Contract</span> <span class="k">for</span> <span class="n">NextTxPool</span> <span class="p">{</span>
    <span class="nd">declare!</span> <span class="p">{</span><span class="n">then</span><span class="p">,</span> <span class="nn">Self</span><span class="p">::</span><span class="n">ejection</span><span class="p">}</span>
    <span class="nd">declare!</span> <span class="p">{</span><span class="n">updatable</span><span class="o">&lt;</span><span class="n">DoTx</span><span class="o">&gt;</span><span class="p">,</span> <span class="nn">Self</span><span class="p">::</span><span class="n">do_tx</span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Now we’ll define the logic for ejecting from the pool:</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span> <span class="n">NextTxPool</span> <span class="p">{</span>
    <span class="c">/// Sum Up all the balances</span>
    <span class="k">fn</span> <span class="nf">total</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Amount</span> <span class="p">{</span>
        <span class="k">self</span><span class="py">.members</span>
            <span class="nf">.values</span><span class="p">()</span>
            <span class="nf">.cloned</span><span class="p">()</span>
            <span class="nf">.map</span><span class="p">(</span><span class="nn">Amount</span><span class="p">::</span><span class="n">from</span><span class="p">)</span>
            <span class="nf">.fold</span><span class="p">(</span><span class="nn">Amount</span><span class="p">::</span><span class="nf">from_sat</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="p">|</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">|</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="c">/// Only compile an ejection if the pool has other users in it, otherwise</span>
    <span class="c">/// it's base case.</span>
    <span class="nd">#[compile_if]</span>
    <span class="k">fn</span> <span class="nf">has_eject</span><span class="p">(</span><span class="k">self</span><span class="p">,</span> <span class="n">ctx</span><span class="p">:</span> <span class="n">Context</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="k">self</span><span class="py">.members</span><span class="nf">.len</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="p">{</span>
            <span class="nn">ConditionalCompileType</span><span class="p">::</span><span class="n">Required</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="nn">ConditionalCompileType</span><span class="p">::</span><span class="n">Never</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="c">/// Split the pool in two -- users can eject multiple times to fully eject.</span>
    <span class="nd">#[then(compile_if</span> <span class="nd">=</span> <span class="s">"[Self::has_eject]"</span><span class="nd">)]</span>
    <span class="k">fn</span> <span class="nf">ejection</span><span class="p">(</span><span class="k">self</span><span class="p">,</span> <span class="n">ctx</span><span class="p">:</span> <span class="n">Context</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">t</span> <span class="o">=</span> <span class="n">ctx</span><span class="nf">.template</span><span class="p">();</span>
        <span class="k">let</span> <span class="n">mid</span> <span class="o">=</span> <span class="p">(</span><span class="k">self</span><span class="py">.members</span><span class="nf">.len</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
        <span class="c">// find the middle</span>
        <span class="k">let</span> <span class="n">key</span> <span class="o">=</span> <span class="k">self</span><span class="py">.members</span><span class="nf">.keys</span><span class="p">()</span><span class="nf">.nth</span><span class="p">(</span><span class="n">mid</span><span class="p">)</span><span class="nf">.expect</span><span class="p">(</span><span class="s">"must be present"</span><span class="p">);</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">pool_one</span><span class="p">:</span> <span class="n">NextTxPool</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.clone</span><span class="p">();</span>
        <span class="n">pool_one</span><span class="py">.sequence</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="k">let</span> <span class="n">pool_two</span> <span class="o">=</span> <span class="n">NextTxPool</span> <span class="p">{</span>
            <span class="c">// removes the back half including key</span>
            <span class="n">members</span><span class="p">:</span> <span class="n">pool_one</span><span class="py">.members</span><span class="nf">.split_off</span><span class="p">(</span><span class="o">&amp;</span><span class="n">key</span><span class="p">),</span>
            <span class="n">sequence</span><span class="p">:</span> <span class="k">self</span><span class="py">.sequence</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
            <span class="n">sig_needed</span><span class="p">:</span> <span class="k">self</span><span class="py">.sig_needed</span><span class="p">,</span>
        <span class="p">};</span>
        <span class="k">let</span> <span class="n">amt_one</span> <span class="o">=</span> <span class="n">pool_one</span><span class="nf">.total</span><span class="p">();</span>
        <span class="k">let</span> <span class="n">amt_two</span> <span class="o">=</span> <span class="n">pool_two</span><span class="nf">.total</span><span class="p">();</span>
        <span class="n">t</span><span class="nf">.add_output</span><span class="p">(</span><span class="n">amt_one</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pool_one</span><span class="p">,</span> <span class="nb">None</span><span class="p">)</span><span class="o">?</span>
            <span class="nf">.add_output</span><span class="p">(</span><span class="n">amt_two</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pool_two</span><span class="p">,</span> <span class="nb">None</span><span class="p">)</span><span class="o">?</span>
            <span class="nf">.into</span><span class="p">()</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<p>Next, we’ll define some data types for instructing the pool to update:</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">/// Payment Request</span>
<span class="nd">#[derive(Deserialize,</span> <span class="nd">JsonSchema)]</span>
<span class="k">struct</span> <span class="n">PaymentRequest</span> <span class="p">{</span>
    <span class="c">/// # Signature</span>
    <span class="c">/// hex encoded signature of the fee, sequence number, and payments</span>
    <span class="n">hex_der_sig</span><span class="p">:</span> <span class="nb">String</span><span class="p">,</span>
    <span class="n">fee</span><span class="p">:</span> <span class="n">AmountF64</span><span class="p">,</span>
    <span class="n">payments</span><span class="p">:</span> <span class="n">BTreeMap</span><span class="o">&lt;</span><span class="n">Address</span><span class="p">,</span> <span class="n">AmountF64</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">}</span>
<span class="c">/// New Update message for generating a transaction from.</span>
<span class="nd">#[derive(Deserialize,</span> <span class="nd">JsonSchema)]</span>
<span class="k">struct</span> <span class="n">DoTx</span> <span class="p">{</span>
    <span class="c">/// # Payments</span>
    <span class="c">/// A mapping of public key in members to signed list of payouts with a fee rate.</span>
    <span class="n">payments</span><span class="p">:</span> <span class="n">HashMap</span><span class="o">&lt;</span><span class="n">PublicKey</span><span class="p">,</span> <span class="n">PaymentRequest</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">}</span>
<span class="c">/// required...</span>
<span class="k">impl</span> <span class="n">Default</span> <span class="k">for</span> <span class="n">DoTx</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">default</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="n">Self</span> <span class="p">{</span>
        <span class="n">DoTx</span> <span class="p">{</span>
            <span class="n">payments</span><span class="p">:</span> <span class="nn">HashMap</span><span class="p">::</span><span class="nf">new</span><span class="p">(),</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="k">impl</span> <span class="n">StatefulArgumentsTrait</span> <span class="k">for</span> <span class="n">DoTx</span> <span class="p">{}</span>

<span class="c">/// helper for rust type system issue</span>
<span class="k">fn</span> <span class="nf">default_coerce</span><span class="p">(</span>
    <span class="n">k</span><span class="p">:</span> <span class="o">&lt;</span><span class="n">NextTxPool</span> <span class="k">as</span> <span class="n">Contract</span><span class="o">&gt;</span><span class="p">::</span><span class="n">StatefulArguments</span><span class="p">,</span>
<span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Result</span><span class="o">&lt;</span><span class="n">DoTx</span><span class="p">,</span> <span class="n">CompilationError</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="nf">Ok</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Lastly, we’ll define the logic for actually doing the update:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span> <span class="n">NextTxPool</span> <span class="p">{</span>
    <span class="c">/// all signed the transaction!</span>
    <span class="nd">#[guard]</span>
    <span class="k">fn</span> <span class="nf">all_signed</span><span class="p">(</span><span class="k">self</span><span class="p">,</span> <span class="n">ctx</span><span class="p">:</span> <span class="n">Context</span><span class="p">)</span> <span class="p">{</span>
        <span class="nn">Clause</span><span class="p">::</span><span class="nf">Threshold</span><span class="p">(</span>
            <span class="k">self</span><span class="py">.members</span><span class="nf">.len</span><span class="p">(),</span>
            <span class="k">self</span><span class="py">.members</span><span class="nf">.keys</span><span class="p">()</span><span class="nf">.cloned</span><span class="p">()</span><span class="nf">.map</span><span class="p">(</span><span class="nn">Clause</span><span class="p">::</span><span class="n">Key</span><span class="p">)</span><span class="nf">.collect</span><span class="p">(),</span>
        <span class="p">)</span>
    <span class="p">}</span>
    <span class="c">/// This Function will create a proposed transaction that is safe to sign</span>
    <span class="c">/// given a list of data from participants.</span>
    <span class="nd">#[continuation(</span>
        <span class="nd">guarded_by</span> <span class="nd">=</span> <span class="s">"[Self::all_signed]"</span><span class="nd">,</span>
        <span class="nd">coerce_args</span> <span class="nd">=</span> <span class="s">"default_coerce"</span><span class="nd">,</span>
        <span class="nd">web_api</span>
    <span class="nd">)]</span>
    <span class="k">fn</span> <span class="nf">do_tx</span><span class="p">(</span><span class="k">self</span><span class="p">,</span> <span class="n">ctx</span><span class="p">:</span> <span class="n">Context</span><span class="p">,</span> <span class="n">update</span><span class="p">:</span> <span class="n">DoTx</span><span class="p">)</span> <span class="p">{</span>
        <span class="c">// don't allow empty updates.</span>
        <span class="k">if</span> <span class="n">update</span><span class="py">.payments</span><span class="nf">.is_empty</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nf">empty</span><span class="p">();</span>
        <span class="p">}</span>
        <span class="c">// collect members with updated balances here</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">new_members</span> <span class="o">=</span> <span class="k">self</span><span class="py">.members</span><span class="nf">.clone</span><span class="p">();</span>
        <span class="c">// verification context</span>
        <span class="k">let</span> <span class="n">secp</span> <span class="o">=</span> <span class="nn">Secp256k1</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
        <span class="c">// collect all the payments</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">all_payments</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[];</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">spent</span> <span class="o">=</span> <span class="nn">Amount</span><span class="p">::</span><span class="nf">from_sat</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
        <span class="c">// for each payment...</span>
        <span class="k">for</span> <span class="p">(</span>
            <span class="n">from</span><span class="p">,</span>
            <span class="n">PaymentRequest</span> <span class="p">{</span>
                <span class="n">hex_der_sig</span><span class="p">,</span>
                <span class="n">fee</span><span class="p">,</span>
                <span class="n">payments</span><span class="p">,</span>
            <span class="p">},</span>
        <span class="p">)</span> <span class="n">in</span> <span class="n">update</span><span class="py">.payments</span><span class="nf">.iter</span><span class="p">()</span>
        <span class="p">{</span>
            <span class="c">// every from must be in the members</span>
            <span class="k">let</span> <span class="n">balance</span> <span class="o">=</span> <span class="k">self</span>
                <span class="py">.members</span>
                <span class="nf">.get</span><span class="p">(</span><span class="n">from</span><span class="p">)</span>
                <span class="nf">.ok_or</span><span class="p">(</span><span class="nn">CompilationError</span><span class="p">::</span><span class="n">TerminateCompilation</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
            <span class="k">let</span> <span class="n">new_balance</span> <span class="o">=</span> <span class="nn">Amount</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="o">*</span><span class="n">balance</span><span class="p">)</span>
                <span class="o">-</span> <span class="p">(</span><span class="n">payments</span>
                    <span class="nf">.values</span><span class="p">()</span>
                    <span class="nf">.cloned</span><span class="p">()</span>
                    <span class="nf">.map</span><span class="p">(</span><span class="nn">Amount</span><span class="p">::</span><span class="n">from</span><span class="p">)</span>
                    <span class="nf">.fold</span><span class="p">(</span><span class="nn">Amount</span><span class="p">::</span><span class="nf">from_sat</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="p">|</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">|</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">)</span>
                    <span class="o">+</span> <span class="nn">Amount</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="o">*</span><span class="n">fee</span><span class="p">));</span>
            <span class="c">// check for no underflow</span>
            <span class="k">if</span> <span class="n">new_balance</span><span class="nf">.as_sat</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="p">{</span>
                <span class="k">return</span> <span class="nf">Err</span><span class="p">(</span><span class="nn">CompilationError</span><span class="p">::</span><span class="n">TerminateCompilation</span><span class="p">);</span>
            <span class="p">}</span>
            <span class="c">// updates the balance or remove if empty</span>
            <span class="k">if</span> <span class="n">new_balance</span><span class="nf">.as_sat</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
                <span class="n">new_members</span><span class="nf">.insert</span><span class="p">(</span><span class="n">from</span><span class="nf">.clone</span><span class="p">(),</span> <span class="n">new_balance</span><span class="nf">.into</span><span class="p">());</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="n">new_members</span><span class="nf">.remove</span><span class="p">(</span><span class="n">from</span><span class="p">);</span>
            <span class="p">}</span>

            <span class="c">// collect all the payment</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">address</span><span class="p">,</span> <span class="n">amt</span><span class="p">)</span> <span class="n">in</span> <span class="n">payments</span><span class="nf">.iter</span><span class="p">()</span> <span class="p">{</span>
                <span class="n">spent</span> <span class="o">+=</span> <span class="nn">Amount</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="o">*</span><span class="n">amt</span><span class="p">);</span>
                <span class="n">all_payments</span><span class="nf">.push</span><span class="p">(</span><span class="n">Payment</span> <span class="p">{</span>
                    <span class="n">address</span><span class="p">:</span> <span class="n">address</span><span class="nf">.clone</span><span class="p">(),</span>
                    <span class="n">amount</span><span class="p">:</span> <span class="nn">Amount</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="o">*</span><span class="n">amt</span><span class="p">)</span><span class="nf">.into</span><span class="p">(),</span>
                <span class="p">})</span>
            <span class="p">}</span>
            <span class="c">// Check the signature for this request</span>
            <span class="c">// came from this user</span>
            <span class="k">if</span> <span class="k">self</span><span class="py">.sig_needed</span> <span class="p">{</span>
                <span class="k">let</span> <span class="k">mut</span> <span class="n">hasher</span> <span class="o">=</span> <span class="nn">sha256</span><span class="p">::</span><span class="nn">Hash</span><span class="p">::</span><span class="nf">engine</span><span class="p">();</span>
                <span class="n">hasher</span><span class="nf">.write</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="py">.sequence</span><span class="nf">.to_le_bytes</span><span class="p">());</span>
                <span class="n">hasher</span><span class="nf">.write</span><span class="p">(</span><span class="o">&amp;</span><span class="nn">Amount</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="o">*</span><span class="n">fee</span><span class="p">)</span><span class="nf">.as_sat</span><span class="p">()</span><span class="nf">.to_le_bytes</span><span class="p">());</span>
                <span class="k">for</span> <span class="p">(</span><span class="n">address</span><span class="p">,</span> <span class="n">amt</span><span class="p">)</span> <span class="n">in</span> <span class="n">payments</span><span class="nf">.iter</span><span class="p">()</span> <span class="p">{</span>
                    <span class="n">hasher</span><span class="nf">.write</span><span class="p">(</span><span class="o">&amp;</span><span class="nn">Amount</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="o">*</span><span class="n">amt</span><span class="p">)</span><span class="nf">.as_sat</span><span class="p">()</span><span class="nf">.to_le_bytes</span><span class="p">());</span>
                    <span class="n">hasher</span><span class="nf">.write</span><span class="p">(</span><span class="n">address</span><span class="nf">.script_pubkey</span><span class="p">()</span><span class="nf">.as_bytes</span><span class="p">());</span>
                <span class="p">}</span>
                <span class="k">let</span> <span class="n">h</span> <span class="o">=</span> <span class="nn">sha256</span><span class="p">::</span><span class="nn">Hash</span><span class="p">::</span><span class="nf">from_engine</span><span class="p">(</span><span class="n">hasher</span><span class="p">);</span>
                <span class="k">let</span> <span class="n">m</span> <span class="o">=</span> <span class="nn">Message</span><span class="p">::</span><span class="nf">from_slice</span><span class="p">(</span><span class="o">&amp;</span><span class="n">h</span><span class="nf">.as_inner</span><span class="p">()[</span><span class="o">..</span><span class="p">])</span><span class="nf">.expect</span><span class="p">(</span><span class="s">"Correct Size"</span><span class="p">);</span>
                <span class="k">let</span> <span class="n">signed</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">u8</span><span class="o">&gt;</span> <span class="o">=</span> <span class="nn">FromHex</span><span class="p">::</span><span class="nf">from_hex</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hex_der_sig</span><span class="p">)</span>
                    <span class="nf">.map_err</span><span class="p">(|</span><span class="mi">_</span><span class="p">|</span> <span class="nn">CompilationError</span><span class="p">::</span><span class="n">TerminateCompilation</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
                <span class="k">let</span> <span class="n">sig</span> <span class="o">=</span> <span class="nn">Signature</span><span class="p">::</span><span class="nf">from_der</span><span class="p">(</span><span class="o">&amp;</span><span class="n">signed</span><span class="p">)</span>
                    <span class="nf">.map_err</span><span class="p">(|</span><span class="mi">_</span><span class="p">|</span> <span class="nn">CompilationError</span><span class="p">::</span><span class="n">TerminateCompilation</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
                <span class="k">let</span> <span class="mi">_</span><span class="p">:</span> <span class="p">()</span> <span class="o">=</span> <span class="n">secp</span>
                    <span class="nf">.verify</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sig</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">from</span><span class="py">.key</span><span class="p">)</span>
                    <span class="nf">.map_err</span><span class="p">(|</span><span class="mi">_</span><span class="p">|</span> <span class="nn">CompilationError</span><span class="p">::</span><span class="n">TerminateCompilation</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="c">// Send any leftover funds to a new pool</span>
        <span class="k">let</span> <span class="n">change</span> <span class="o">=</span> <span class="n">NextTxPool</span> <span class="p">{</span>
            <span class="n">members</span><span class="p">:</span> <span class="n">new_members</span><span class="p">,</span>
            <span class="n">sequence</span><span class="p">:</span> <span class="k">self</span><span class="py">.sequence</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
            <span class="n">sig_needed</span><span class="p">:</span> <span class="k">self</span><span class="py">.sig_needed</span><span class="p">,</span>
        <span class="p">};</span>
        <span class="c">// We'll use the contract from our last post to make the state</span>
        <span class="c">// transitions more efficient!</span>
        <span class="c">// Think about what else could be fun here though...</span>
        <span class="k">let</span> <span class="n">out</span> <span class="o">=</span> <span class="n">TreePay</span> <span class="p">{</span>
            <span class="n">participants</span><span class="p">:</span> <span class="n">all_payments</span><span class="p">,</span>
            <span class="n">radix</span><span class="p">:</span> <span class="mi">4</span><span class="p">,</span>
        <span class="p">};</span>
        <span class="n">ctx</span><span class="nf">.template</span><span class="p">()</span>
            <span class="nf">.add_output</span><span class="p">(</span><span class="n">change</span><span class="nf">.total</span><span class="p">(),</span> <span class="o">&amp;</span><span class="n">change</span><span class="p">,</span> <span class="nb">None</span><span class="p">)</span><span class="o">?</span>
            <span class="nf">.add_output</span><span class="p">(</span><span class="n">spent</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">out</span><span class="p">,</span> <span class="nb">None</span><span class="p">)</span><span class="o">?</span>
            <span class="nf">.into</span><span class="p">()</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Now it’s pretty neat – rather than “exercise for the reader”, we can have Sapio
generate payment pool updates for us. And exiting from the pool is very
efficient and keeps most users online. But speaking of exercises for the reader,
try thinking through these extensions<sup id="fnref:try" role="doc-noteref"><a href="#fn:try" class="footnote" rel="footnote">6</a></sup>…</p>

<h4 id="no-code-payout-to-where">No Code: Payout to where?</h4>

<p>Payouts in this version are defined as being to an address.</p>

<p>How creative can we get with that? What if the payment request is 1 BTC to
address X and we generated X as a 1 BTC expecting Vault in Sapio?</p>

<p>What else cool can we do?</p>

<h4 id="cut-through">Cut-through</h4>

<p>We could make our <code class="language-plaintext highlighter-rouge">DoTx</code> differentiate between internal and external payouts. An
internal payout would allow for adding a new key OR for increasing the balance
of an existing key <em>before</em> other payments are processed. E.g., suppose we have
Alice with 1 BTC and Bob with 2, under the code above Alice sending 0.5 to Bob
and Bob sending 2.1 to Carol externally would fail and would remove funds from
the pool. If we want to keep funds in the pool, we can do that! And if we want
the balance from new internal transfers, could process before any deductions.</p>

<p>Internal tranfers to multiple addresses per user can also be used to improve
privacy!</p>

<h4 id="adding-inputs">Adding Inputs</h4>

<p>It should also be possible to have external inputs add balance to the pool
during any state update.</p>

<h4 id="fees">Fees?</h4>

<p>I basically glance over fees in this presentation… But there is more work to
be done to control and process fees fairly!</p>

<h4 id="cold-er-ejections">Cold-er Ejections</h4>

<p>If you get kicked out of a pool because you went offline, might you be able to
specify – per user – some sort of vault program for the evicted coins to go into?</p>

<h4 id="howdy-partner">Howdy Partner</h4>

<p>Who is next to whom is actually kinda relevant for a Pool with Efficient Ejections.</p>

<p>For example, if the pool splits because of an undersea cable breaking off France
and Britain, dividing users based on English or French would be much better than
random  because after one transaction you could have all the English and French
users split and able to communicate again.</p>

<p>What different heuristics might you group people by? Reputation system? Amount
of funds at stake? Random? Sorted lexicographically?</p>

<h2 id="lets-look-at-some-pictures">Let’s look at some pictures:</h2>

<h6 id="creating-a-pool">Creating a Pool</h6>
<p><img src="/public/img/bitcoin/advent/payment_pool/1.png" alt="" /></p>
<h6 id="pool-created">Pool Created!</h6>
<p><img src="/public/img/bitcoin/advent/payment_pool/2.png" alt="" /></p>
<h6 id="inspecting-the-root">Inspecting the Root</h6>
<p><img src="/public/img/bitcoin/advent/payment_pool/3.png" alt="" /></p>
<h6 id="entering-an-update">Entering an update</h6>
<p><img src="/public/img/bitcoin/advent/payment_pool/4.png" alt="" /></p>
<h6 id="updated-tx-graph">Updated TX Graph</h6>
<p>(had a ux bug, need to fix it before I add this :p)</p>

<h2 id="do-payment-pools-need-ctv">Do Payment Pools Need CTV?</h2>

<p>Not necessarily. Payment pools as shown can be done <em>today</em>, but they require
participants to use their own emulation / pre-signing servers before depositing
funds.</p>

<p>This might not seem bad; we already need everyone online for an update, right?
It’s truly not awful. However, many use cases of payment pool essentially
require being able to generate a payment pool without having all of the parties
online at the time of creation. E.g., imagine that your exchange matches you
with reputable payment pool counterparties when you withdraw (if you request
it). We’ll see the need concretely in a future post.</p>

<h2 id="what-about-the-taproots">What about the Taproots</h2>

<p>Unfortunately, rust-bitcoin/miniscript work on Taproot is still ongoing, so I
can’t show you how cool Taproot is for this. But essentially, our
<code class="language-plaintext highlighter-rouge">Self::all_signed</code> clauses become just a single key! And they can be
non-interactively generated at every level for the tree-ejection version. This is
great! It will work pretty much automatically without changing the user-code once
the compiler supports taproot. Huge boon for privacy and efficiency!</p>

<h2 id="contrast-this-vs">Contrast this V.S….</h2>
<p>As noted<sup id="fnref:background:1" role="doc-noteref"><a href="#fn:background" class="footnote" rel="footnote">1</a></sup>, there are some other proposals out there.</p>

<p>It’s the author’s opinion that Sapio + CTV are the best form of payment pool
compared to alternatives for both scalability and privacy. To fully understand
why is a lot more technical than this already technical post (beleive it or not).</p>

<p>If you want to get into it,
you can see my accounting for costs on the mailing list:</p>

<ul>
  <li><a href="https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2021-September/019424.html">TLUV v CTV</a></li>
  <li><a href="https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-June/017968.html">CoinPool v CTV</a></li>
</ul>

<p>It boils down to a few things:</p>

<ol>
  <li>Cheaper</li>
  <li>Simpler</li>
  <li>More Composable</li>
  <li>Better Privacy</li>
</ol>

<hr />

<p>In posts coming soon we’ll get a heck’n lot more creative with what goes inside
a payment pool, including lightning, mining pools, and “daos”! But that’s all
for today.</p>

<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:background" role="doc-endnote">
      <p>Credit is boring, but I presented the ideas for them originally at SF Bitdevs in May 2019, and Greg Maxwell followed up on the concept more thoroughly in <a href="https://freenode.irclog.whitequark.org/bitcoin-wizards/2019-05-21#24639752">#bitcoin-wizards</a> afterwards. <a href="https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-June/017964.html">Gleb and Antoine</a> have also been thinking about it recently (under the name Coin Pools – to be honest we’ll have to duke it out since I like the name Coin Pools better than Payment Pool so unclear if it’s going to be like “payment channels” for a variety of designs or “the lightning network”…), as well as AJ/Greg with <a href="https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2021-September/019419.html">TLUV</a>. <a href="#fnref:background" class="reversefootnote" role="doc-backlink">&#8617;</a> <a href="#fnref:background:1" class="reversefootnote" role="doc-backlink">&#8617;<sup>2</sup></a></p>
    </li>
    <li id="fn:single" role="doc-endnote">
      <p>Debatably, one could have a protocol where it’s a number of utxos but the core idea is that it should not be 1 user to 1 utxo. <a href="#fnref:single" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:implies" role="doc-endnote">
      <p>This implies that no user can block the other users. <a href="#fnref:implies" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:unan" role="doc-endnote">
      <p>Usually all users, not a subset. But possible to do fewer than all. <a href="#fnref:unan" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:greg" role="doc-endnote">
      <p>Credit to Greg Maxwell for this description. It’s potent. <a href="#fnref:greg" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:try" role="doc-endnote">
      <p>please do try! I think you can :) <a href="#fnref:try" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>

  </div>
<hr>
  
<hr>
  <div class="post">
    <h2 class="post-title">
        <a href="/bitcoin/2021/12/09/advent-12/">
        Congestion Control
      </a>
  </h2>
  <h4>Day 12: Rubin's Bitcoin Advent Calendar</h4>


    <span class="post-date">09 Dec 2021</span>

    <p><em>Welcome to day 12 of my Bitcoin Advent Calendar. You can see an index of all
the posts <a href="/advent21">here</a> or subscribe at
<a href="https://judica.org/join">judica.org/join</a> to get new posts in your inbox</em></p>

<p>Congestion is an ugly word, eh? When I hear it my fake synthesia triggers green
slime feeling, being stuck in traffic with broken AC, and ~the bread line~
waiting for your order at a crowded restaurant when you’re super starving. All
not good things.</p>

<p>So Congestion Control sounds pretty sweet right? We can’t do anything about the
demand itself, but maybe we can make the experience better. We can take a mucinex,
drive in the HOV lane, and eat the emergency bar you keep in your bag.</p>

<p>How might this be used in Bitcoin?</p>

<ol>
  <li>Exchange collects N addresses they need to pay some bitcoin</li>
  <li>Exchange inputs into this contract</li>
  <li>Exchanges gets a single-output transaction, which they broadcast with high fee to get quick confirmation.</li>
  <li>Exchange distributes the redemption paths to all recipients (e.g. via mempool, email, etc).</li>
  <li>Users verify that the funds are “locked in” with this contract.</li>
  <li>Party</li>
  <li>Over time, when users are willing to pay fees, they CPFP pay for their redemptions (worst case cost \(O(\log N)\))</li>
</ol>

<p>Throughout this post, we’ll show how to build the above logic in Sapio!</p>

<hr />

<p>Before we get into that…</p>

<h1 id="talk-nerdy-to-me">Talk Nerdy To Me</h1>

<p>Let’s define some core concepts… Don’t worry too much if these are a bit hard
to get, it’s just useful context to have or think about.</p>

<h3 id="latency">Latency</h3>

<p>Latency is the time from some notion of “started” to “stopped”. In Bitcoin you could think of the latency from 0 confirmations on a transaction (in mempool) to 1 confirmation (in a block), which is minimally expected to be 10
minutes for high fee transactions, but could be longer depending on the other transactions.</p>

<h3 id="fairness">Fairness</h3>

<p>Fairness is a measure of how “equitable” a distribution of goods or services is.
For example, suppose I want to divide 10 cookies among 10 children.</p>

<p>What if 1 child gets two cookies and the other 9 get 8/9ths of a cookie each? Or
what if 1 child gets no cookie and the other 9 get 10/9ths of a cookie each? How
fair is that?</p>

<p>Mathematicians and computer scientists love to come up with different measures
of fairness to be able to quantatatively compare these scenarios and their
relative fairness.</p>

<p>In Bitcoin we might think of different types of fairness: how long does your
transaction spend in the mempool? How much fee did you pay?</p>

<h3 id="throughput--capacity">Throughput &amp; Capacity</h3>
<p>Let’s spend another moment on fairness. Perfectly fair would be:</p>

<ol>
  <li>All children get 1 cookie</li>
  <li>All children get 1/10th of 1 cookie.</li>
  <li>All children get 0 cookies.</li>
</ol>

<p>Clearly only one of these is particularly efficient.</p>

<p>Thus, we don’t just want to measure fairness, we also want to measure the
throughput against the capacity. The capacity is the maximum throughput, and the
the throughput is essentially how many of those cookies get eaten (usually, over
time). Now let’s look at our prior scenarios:</p>

<ol>
  <li>All children get 1 cookie: Perfect Throughput.</li>
  <li>All children get 1/10th of 1 cookie: 1/10th Throughtput/Capacity.</li>
  <li>All children get 0 cookies: 0 Throughput :(</li>
</ol>

<p>In this case it seems simple: why not just divide the cookies you big butt!</p>

<p>Well sometimes it’s hard to coordinate the sharing of these resources. For
example, think about if the cookies had to be given out in a buffet. The first
person might just take two cookies, not aware there were other kids who wouldn’t
get one!</p>

<p>This maps well onto the Bitcoin network. A really rich group of people might do
a bunch of relatively high fee transactions that are low importance to them and
inadvertently price out lower fee transactions that are more important to the
sender. It’s not malicious, just a consequence of having more money. So even
though Bitcoin can achieve 1MB of base transaction data every 10 minutes, that
capacity might get filled with a couple big consolidation transactions instead
of many transfers.</p>

<h3 id="burst--over-provisioning">Burst &amp; Over Provisioning</h3>

<p>One issue that comes up in systems is that users show up randomly. How often
have you been at a restaurant with no line, you order your food, and then as
soon as you sit down the line has ten people in it? Lucky me, you think. <em>I
showed up at the right time!</em>. But then ten minutes later the line is clear.</p>

<p>Customers show up kind of randomly. And thus we see big bursts of activity.
Typically, in order to accomodate the bursts a restaurant must over-provision
it’s staff. They only make money when customers are there, and they need to
serve them quickly. But in between bursts, staff might just be watching grass
grow.</p>

<p>The same is true for Bitcoin. Transactions show up somewhat unpredictably, so
ideally Bitcoin would have ample space to accomodate any burst (this isn’t
true).</p>

<h3 id="littles-law">Little’s Law</h3>

<p>Little’s law is a deceptively simple concept:</p>

\[L = \lambda \times W\]

<p>where \(L = \) length of the queue, \(\lambda = \) the arrival rate and
\(W=\) the average time a customer spends in the system.</p>

<p>What’s remarkable about it is that it makes almost no assumptions about the underlying process.</p>

<p>This can be used to think about, e.g., a mempool.</p>

<p>Suppose there are 10,000 transactions in the mempool, and based on historical
data we see 57 txns a minute.</p>

\[\frac{10,000 \texttt{ minutes}}{57 \texttt{ transactions per minute}} = 175 \texttt{ minutes}\]

<p>Thus we can infer how long transactions will on average spend waiting in the
mempool, without knowing what the bursts look like! Very cool.</p>

<h2 id="im-just-showing-off">I’m just showing off</h2>

<p>I didn’t really need to make you read that gobbledygook, but I think they are
really useful concepts that anyone who wants to think about the impacts of
congestion &amp; control techniques should keep in mind… Hopefully you learned
something!</p>

<hr />

<h1 id="its-bitcoin-time">It’s Bitcoin Time</h1>

<p>Well, what’s going on in Bitcoin land? When we make a transaction there are
multiple different things going on.</p>

<ol>
  <li>We are spending coins</li>
  <li>We are creating new coins</li>
</ol>

<p>Currently, those two steps occur simultaneously. Think of our cookies. Imagine
if we let one kid get cookies at a time, and they also have to get their milk at
the same time. Then we let the next kid go. It’s going to take</p>

\[T_{milk} + T_{cookies}\]

<p>To get everyone served. What if instead we said kids could get one and then the
other, in separate lines.</p>

<p>Now it will take something closer to \(\max(T_{milk}, T_{cookies})\).<sup id="fnref:simpl" role="doc-noteref"><a href="#fn:simpl" class="footnote" rel="footnote">1</a></sup>
Whichever process is longer will dominate the time. (Probably milk).</p>

<p>Now imagine that getting a cookie takes 1 second per child, and getting a milk
takes 30 seconds. Everyone knows that you can have a cookie and have milk after.
If children take a random amount of time – let’s say on average 3 minutes,
sometimes more, sometimes less – to eat their cookies, then we can serve 10
kids cookies in 10 seconds, making everyone happy, and then fill up the milks
while everyone is enjoying a cookie. However, if we did the opposite – got
milks and then got cookies, it would take much longer for all of the kids to
get something and you’d see chaos.</p>

<p>Back to Bitcoin. Spending coins and creating new coins is a bit like milk and
cookies. We can make the spend correspond to distributing the cookies and
setting up the milk line. And the creating of the new coin can be more akin to
filling up milks whenever a kid wants it.</p>

<p>What this means practically is that by unbundling spending from redeeming we can
serve a much greater number of users that if they were one aggregate product
because we are taking the “expensive part” and letting it happen later than the
“cheap part”. And if we do this cleverly, the “setting up the milk line” in the
splitting of the spend allows all receivers to know they will get their fair share later.</p>

<p>This makes the system much higher throughput (unlimited confirmations of
transfer), lower latency to confirmation (you an see when a spend will
eventually pay you), but higher latency to coin creation in the best case,
although potentially no different than the average case, and (potentially) worse
overall throughput since we have some waste from coordinating the splitting.</p>

<p>It also improves costs because we may be willing to pay a higher price for part
one (since it generates the confirmation) than part two.</p>

<h1 id="can-we-build-it">Can we build it?</h1>

<p>Let’s start with a basic example of congestion control in Sapio.</p>

<p>First we define a payment as just being an Amount and an Address.</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">/// A payment to a specific address</span>
<span class="k">pub</span> <span class="k">struct</span> <span class="n">Payment</span> <span class="p">{</span>
    <span class="c">/// # Amount</span>
    <span class="c">/// The amount to send in btc</span>
    <span class="k">pub</span> <span class="n">amount</span><span class="p">:</span> <span class="n">AmountF64</span><span class="p">,</span>
    <span class="c">/// # Address</span>
    <span class="c">/// The Address to send to</span>
    <span class="k">pub</span> <span class="n">address</span><span class="p">:</span> <span class="n">Address</span><span class="p">,</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Next, we’ll define a helper called <code class="language-plaintext highlighter-rouge">PayThese</code>, which takes a list of contracts
of some kind and pays them after an optional delay in a single transaction.</p>

<p>You can think of this (back to our kids) as calling a group of kids at a time
(e.g., table 1, then table 2) to get their cookies.</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">PayThese</span> <span class="p">{</span>
    <span class="n">contracts</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="p">(</span><span class="n">Amount</span><span class="p">,</span> <span class="nb">Box</span><span class="o">&lt;</span><span class="n">dyn</span> <span class="n">Compilable</span><span class="o">&gt;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="n">fees</span><span class="p">:</span> <span class="n">Amount</span><span class="p">,</span>
    <span class="n">delay</span><span class="p">:</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">AnyRelTimeLock</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">}</span>
<span class="k">impl</span> <span class="n">PayThese</span> <span class="p">{</span>
    <span class="nd">#[then]</span>
    <span class="k">fn</span> <span class="nf">expand</span><span class="p">(</span><span class="k">self</span><span class="p">,</span> <span class="n">ctx</span><span class="p">:</span> <span class="n">Context</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">bld</span> <span class="o">=</span> <span class="n">ctx</span><span class="nf">.template</span><span class="p">();</span>
        <span class="c">// Add an output for each contract</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">amt</span><span class="p">,</span> <span class="n">ct</span><span class="p">)</span> <span class="n">in</span> <span class="k">self</span><span class="py">.contracts</span><span class="nf">.iter</span><span class="p">()</span> <span class="p">{</span>
            <span class="n">bld</span> <span class="o">=</span> <span class="n">bld</span><span class="nf">.add_output</span><span class="p">(</span><span class="o">*</span><span class="n">amt</span><span class="p">,</span> <span class="n">ct</span><span class="nf">.as_ref</span><span class="p">(),</span> <span class="nb">None</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="c">// if there is a delay, add it</span>
        <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">delay</span><span class="p">)</span> <span class="o">=</span> <span class="k">self</span><span class="py">.delay</span> <span class="p">{</span>
            <span class="n">bld</span> <span class="o">=</span> <span class="n">bld</span><span class="nf">.set_sequence</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">delay</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="c">// pay some fees</span>
        <span class="n">bld</span><span class="nf">.add_fees</span><span class="p">(</span><span class="k">self</span><span class="py">.fees</span><span class="p">)</span><span class="o">?</span><span class="nf">.into</span><span class="p">()</span>
    <span class="p">}</span>

    <span class="k">fn</span> <span class="nf">total_to_pay</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Amount</span> <span class="p">{</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">amt</span> <span class="o">=</span> <span class="k">self</span><span class="py">.fees</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">_</span><span class="p">)</span> <span class="n">in</span> <span class="k">self</span><span class="py">.contracts</span><span class="nf">.iter</span><span class="p">()</span> <span class="p">{</span>
            <span class="n">amt</span> <span class="o">+=</span> <span class="o">*</span><span class="n">x</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">amt</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="k">impl</span> <span class="n">Contract</span> <span class="k">for</span> <span class="n">PayThese</span> <span class="p">{</span>
    <span class="nd">declare!</span> <span class="p">{</span><span class="n">then</span><span class="p">,</span> <span class="nn">Self</span><span class="p">::</span><span class="n">expand</span><span class="p">}</span>
    <span class="nd">declare!</span> <span class="p">{</span><span class="n">non</span> <span class="n">updatable</span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Lastly, we’ll define the logic for congestion control. The basics of what is
happening is we are going to define two transactions: One which pays from A -&gt;
B, and then one which is guaranteed in B’s script to pay from B -&gt; {1…n}. This
splits the confirmation txn from the larger payout txn.</p>

<p>However, we’re going to be a little more clever than that. We’ll apply this principle
recursively to create a tree.</p>

<p>Essentially what we are going to do is to take our 10 kids and then divide them
into groups of 2 (or whatever radix). E.g.: <code class="language-plaintext highlighter-rouge">{1,2,3,4,5,6,7,8,9,10}</code> would become
<code class="language-plaintext highlighter-rouge">{ {1,2}, {3,4}, {5,6}, {7,8}, {9,10} }</code>. The magic happens when we recursively
apply this idea, like below:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{1,2,3,4,5,6,7,8,9,10}
{ {1,2}, {3,4}, {5,6}, {7,8}, {9,10} }
{ { {1,2}, {3,4} }, { {5,6}, {7,8} }, {9,10} }
{ { {1,2}, {3,4} }, { { { 5,6}, {7,8} }, {9,10} } }
{ { { {1,2}, {3,4}}, { { {5,6}, {7,8} }, {9,10} } } }
</code></pre></div></div>

<p>The end result of this grouping is a single group! So now we could do a
transaction to pay/give cookies to that one group, and then if we wanted 9 to
get their cookie/sats We’d only have to publish:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>level 0 to: Address({ { { {1,2}, {3,4} }, { { {5,6}, {7,8} }, {9,10} } } })
level 1 to: Address({ { {5,6}, {7,8} }, {9,10} } })
level 2 to: Address({9,10})
</code></pre></div></div>

<p>Now let’s show that in code:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">/// # Tree Payment Contract</span>
<span class="c">/// This contract is used to help decongest bitcoin</span>
<span class="c">//// while giving users full confirmation of transfer.</span>
<span class="nd">#[derive(JsonSchema,</span> <span class="nd">Serialize,</span> <span class="nd">Deserialize)]</span>
<span class="k">pub</span> <span class="k">struct</span> <span class="n">TreePay</span> <span class="p">{</span>
    <span class="c">/// # Payments</span>
    <span class="c">/// all of the payments needing to be sent</span>
    <span class="k">pub</span> <span class="n">participants</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">Payment</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="c">/// # Tree Branching Factor</span>
    <span class="c">/// the radix of the tree to build.</span>
    <span class="c">/// Optimal for users should be around 4 or</span>
    <span class="c">/// 5 (with CTV, not emulators).</span>
    <span class="k">pub</span> <span class="n">radix</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
    <span class="nd">#[serde(with</span> <span class="nd">=</span> <span class="s">"bitcoin::util::amount::serde::as_sat"</span><span class="nd">)]</span>
    <span class="nd">#[schemars(with</span> <span class="nd">=</span> <span class="s">"u64"</span><span class="nd">)]</span>
    <span class="c">/// # Fee Sats (per tx)</span>
    <span class="c">/// The amount of fees per transaction to allocate.</span>
    <span class="k">pub</span> <span class="n">fee_sats_per_tx</span><span class="p">:</span> <span class="nn">bitcoin</span><span class="p">::</span><span class="nn">util</span><span class="p">::</span><span class="nn">amount</span><span class="p">::</span><span class="n">Amount</span><span class="p">,</span>
    <span class="c">/// # Relative Timelock Backpressure</span>
    <span class="c">/// When enabled, exert backpressure by slowing down</span>
    <span class="c">/// tree expansion node by node either by time or blocks</span>
    <span class="k">pub</span> <span class="n">timelock_backpressure</span><span class="p">:</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">AnyRelTimeLock</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">TreePay</span> <span class="p">{</span>
    <span class="nd">#[then]</span>
        <span class="k">fn</span> <span class="nf">expand</span><span class="p">(</span><span class="k">self</span><span class="p">,</span> <span class="n">ctx</span><span class="p">:</span> <span class="n">Context</span><span class="p">)</span> <span class="p">{</span>
            <span class="c">// A queue of all the payments to be made initialized with</span>
            <span class="c">// all the input payments</span>
            <span class="k">let</span> <span class="k">mut</span> <span class="n">queue</span> <span class="o">=</span> <span class="k">self</span>
                <span class="py">.participants</span>
                <span class="nf">.iter</span><span class="p">()</span>
                <span class="nf">.map</span><span class="p">(|</span><span class="n">payment</span><span class="p">|</span> <span class="p">{</span>
                    <span class="c">// Convert the payments to an internal representation</span>
                    <span class="k">let</span> <span class="k">mut</span> <span class="n">amt</span> <span class="o">=</span> <span class="nn">AmountRange</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
                    <span class="n">amt</span><span class="nf">.update_range</span><span class="p">(</span><span class="n">payment</span><span class="py">.amount</span><span class="p">);</span>
                    <span class="k">let</span> <span class="n">b</span><span class="p">:</span> <span class="nb">Box</span><span class="o">&lt;</span><span class="n">dyn</span> <span class="n">Compilable</span><span class="o">&gt;</span> <span class="o">=</span>
                        <span class="nn">Box</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="nn">Compiled</span><span class="p">::</span><span class="nf">from_address</span><span class="p">(</span><span class="n">payment</span><span class="py">.address</span><span class="nf">.clone</span><span class="p">(),</span>
                        <span class="nf">Some</span><span class="p">(</span><span class="n">amt</span><span class="p">)));</span>
                    <span class="p">(</span><span class="n">payment</span><span class="py">.amount</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
                <span class="p">})</span>
                <span class="py">.collect</span><span class="p">::</span><span class="o">&lt;</span><span class="n">VecDeque</span><span class="o">&lt;</span><span class="p">(</span><span class="n">Amount</span><span class="p">,</span> <span class="nb">Box</span><span class="o">&lt;</span><span class="n">dyn</span> <span class="n">Compilable</span><span class="o">&gt;</span><span class="p">)</span><span class="o">&gt;&gt;</span><span class="p">();</span>

            <span class="k">loop</span> <span class="p">{</span>
                <span class="c">// take out a group of size `radix` payments</span>
                <span class="k">let</span> <span class="n">v</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="mi">_</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">queue</span>
                    <span class="nf">.drain</span><span class="p">(</span><span class="mi">0</span><span class="o">..</span><span class="nn">std</span><span class="p">::</span><span class="nn">cmp</span><span class="p">::</span><span class="nf">min</span><span class="p">(</span><span class="k">self</span><span class="py">.radix</span><span class="p">,</span> <span class="n">queue</span><span class="nf">.len</span><span class="p">()))</span>
                    <span class="nf">.collect</span><span class="p">();</span>
                <span class="k">if</span> <span class="n">queue</span><span class="nf">.len</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
                    <span class="c">// in this case, there's no more payments to make so bundle</span>
                    <span class="c">// them up into a final transaction</span>
                    <span class="k">let</span> <span class="k">mut</span> <span class="n">builder</span> <span class="o">=</span> <span class="n">ctx</span><span class="nf">.template</span><span class="p">();</span>
                    <span class="k">for</span> <span class="n">pay</span> <span class="n">in</span> <span class="n">v</span><span class="nf">.iter</span><span class="p">()</span> <span class="p">{</span>
                        <span class="n">builder</span> <span class="o">=</span> <span class="n">builder</span><span class="nf">.add_output</span><span class="p">(</span><span class="n">pay</span><span class="na">.0</span><span class="p">,</span> <span class="n">pay</span><span class="na">.1</span><span class="nf">.as_ref</span><span class="p">(),</span> <span class="nb">None</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
                    <span class="p">}</span>
                    <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">timelock</span><span class="p">)</span> <span class="o">=</span> <span class="k">self</span><span class="py">.timelock_backpressure</span> <span class="p">{</span>
                        <span class="n">builder</span> <span class="o">=</span> <span class="n">builder</span><span class="nf">.set_sequence</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">timelock</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
                    <span class="p">}</span>
                    <span class="n">builder</span> <span class="o">=</span> <span class="n">builder</span><span class="nf">.add_fees</span><span class="p">(</span><span class="k">self</span><span class="py">.fee_sats_per_tx</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
                    <span class="k">return</span> <span class="n">builder</span><span class="nf">.into</span><span class="p">();</span>
                <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                    <span class="c">// There are still more, so make this group and add it to</span>
                    <span class="c">// the back of the queue</span>
                    <span class="k">let</span> <span class="n">pay</span> <span class="o">=</span> <span class="nn">Box</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">PayThese</span> <span class="p">{</span>
                        <span class="n">contracts</span><span class="p">:</span> <span class="n">v</span><span class="p">,</span>
                        <span class="n">fees</span><span class="p">:</span> <span class="k">self</span><span class="py">.fee_sats_per_tx</span><span class="p">,</span>
                        <span class="n">delay</span><span class="p">:</span> <span class="k">self</span><span class="py">.timelock_backpressure</span><span class="p">,</span>
                    <span class="p">});</span>
                    <span class="n">queue</span><span class="nf">.push_back</span><span class="p">((</span><span class="n">pay</span><span class="nf">.total_to_pay</span><span class="p">(),</span> <span class="n">pay</span><span class="p">))</span>
                <span class="p">}</span>
            <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="k">impl</span> <span class="n">Contract</span> <span class="k">for</span> <span class="n">TreePay</span> <span class="p">{</span>
    <span class="nd">declare!</span> <span class="p">{</span><span class="n">then</span><span class="p">,</span> <span class="nn">Self</span><span class="p">::</span><span class="n">expand</span><span class="p">}</span>
    <span class="nd">declare!</span> <span class="p">{</span><span class="n">non</span> <span class="n">updatable</span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>So now what does that look like when we send to it? Let’s do a TreePay with 14 recipients and radix 4:</p>

<p><img src="/public/img/bitcoin/advent/tree_pay.png" alt="sapio studio view of treepay" /></p>

<p>As you can see, the queuing puts some structure into a batched payment! This is
(roughly) the exact same code as above generating these transactions. What this
also means is given an output and a description of the arguments passed to the
contract, anyone can re-generate the expansion transactions and verify that they
can eventually receive their money! These payout proofs can also be delivered in
a pruned form, but that’s just a bonus.</p>

<p>Everyone gets their cookie (confirmation of transfer) immediately, and knows
they can get their milk (spendability) later. A smart wallet could manage your
liquidity over pedning redemptions, so you could passively expand outputs
whenever fees are cheap.</p>

<hr />

<p>There are <strong>a lot</strong> of extensions to this basic design, and we’ll see two really
exciting ones tomorrow and the next day!</p>

<p>If you want to read more about the impact of congestion control on the network,
I previously wrote two articles simulating the impact of congestion control on
the network which you can read here:</p>

<ul>
  <li><a href="https://utxos.org/analysis/bip_simulation/">Congestion Simulation</a></li>
  <li><a href="https://utxos.org/analysis/batching_sim/">Batching Simulation</a></li>
</ul>

<p>What’s great about this is that not only do we make a big benefit for anyone who
wants to use it, we show in the Batching Simulation that even with the overheads
of a TreePay, the incentive compatible behavior around exchange batching can
actually help us use less block space overall.</p>
<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:simpl" role="doc-endnote">
      <p>Simplifying here – I know Amdahl’s Law… <a href="#fnref:simpl" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>

  </div>
<hr>
  
<hr>
  <div class="post">
    <h2 class="post-title">
        <a href="/bitcoin/2021/12/08/advent-11/">
        Inheritence Schemes for Bitcoin
      </a>
  </h2>
  <h4>Day 11: Rubin's Bitcoin Advent Calendar</h4>


    <span class="post-date">08 Dec 2021</span>

    <p><em>Welcome to day 11 of my Bitcoin Advent Calendar. You can see an index of all
the posts <a href="/advent21">here</a> or subscribe at
<a href="https://judica.org/join">judica.org/join</a> to get new posts in your inbox</em></p>

<h2 id="you-are-going-to-die">You are going to die.</h2>

<p>Merry Christmas! Hopefully not any time soon, but one of these days you will shuffle off this mortal coil.</p>

<p>When that day comes, how will you give your loved ones your hard earned bitcoin?</p>

<p>You do have a plan, right?</p>

<p>This post is a continuation of the last post on Vaults. Whereas Vaults focus on trying to keep your coins away from someone, Inheritance focuses on making sure someone does get your coins. Basically opposites!</p>

<h2 id="basic-bitcoin-plans">Basic Bitcoin Plans</h2>

<p>Let’s say you’re a smarty pants and you set the following system up:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(2-of-3 Multisig of my keys) OR (After 1 year, 3-of-5 Multisig of my 4 family members keys and 1 lawyer to tie break)
</code></pre></div></div>

<p>Under this setup, you can spend your funds secured by a multisig. You have to
spend them once a year to keep your greedy family away, but that’s OK.</p>

<p>Until one day, you perish in a boating accident (shouldn’t have gone to that Flamin’ Hot Cheetos Yach Party in Miami).</p>

<p>A year goes by, no one knows where your 2-of-3 keys are, and so the family’s
backup keys go online.</p>

<p>They raid your files and find a utxoset backup with descriptors and know how to
combine their keys (that you made for them most likely…) with offline signing
devices to sign a PSBT, and the money comes out.</p>

<p>If the family can’t agree, a Lawyer who has your will can tie break the execution.</p>

<p>Except wait…</p>

<h2 id="your-kids-are-assholes-just-like-your-spouse">Your kids are assholes, just like your spouse</h2>

<p>So your piece of shit husband/wife doesn’t think the kids should get anything (RIP
college fund), so count them out on signing the tuition payments.</p>

<p>Now we’re down to your 3 kids agreeing and your 1 lawyer.</p>

<p>Your Lawyer thinks your spouse has a bit of a case, so the whole things in
probate as far as they are concerned.</p>

<p>And the kids? Well, the kids don’t want to go to college. You just gifted them
42069 sats each, enough to pay for a ticket on Elon Musk’s spaceship. So they
get together one night, withdraw all the money, and go to Mars. Or the Casino.
Little Jimmy has never seen so much money, so he goes to Vegas for a last huzzah
before the Mars trip, but he blows it all. So Jimmy stays behind, satless, and
the other kids go to mars.</p>

<h2 id="well-that-sucked">Well That Sucked</h2>

<p>And it didn’t have to! What if you could express your last will and testament in
Bitcoin transactions instead of in messy messy multisigs. You Can! Today! No new
features required (although they’d sure be nice…).</p>

<hr />

<h1 id="building-inheritence-schemes-with-sapio">Building Inheritence Schemes with Sapio</h1>

<p>You can make inheritence schemes with Sapio! While it does benefit from having
CTV enabled for various reasons, technically it can work decently without CTV by
pre-signing transactions with a CTV emulator.</p>

<p>Here we’ll develop some interesting primitives that can be used to make various
inheritence guarantees.</p>

<h2 id="making-a-better-dead-man-switch">Making a better Dead Man Switch</h2>

<p>First off, let’s make a better dead man switch. Recall we had to move our funds once a year because of the timelocks.</p>

<p>That was dumb.</p>

<p>Instead, let’s make a challenge of liveness! (again, deep apologies on these
examples, I’m a bit behind on the series so haven’t checked as closely as I
would usually…)</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">/// Opening state of a DeadManSwitch</span>
<span class="nd">#[derive(Clone)]</span>
<span class="k">struct</span> <span class="n">Alive</span> <span class="p">{</span>
    <span class="c">/// Key needed to claim I'm dead</span>
    <span class="n">is_dead</span><span class="p">:</span> <span class="nn">bitcoin</span><span class="p">::</span><span class="n">PublicKey</span><span class="p">,</span>
    <span class="c">/// If someone says i'm dead but I'm alive, backup wallet address</span>
    <span class="n">is_live</span><span class="p">:</span> <span class="nn">bitcoin</span><span class="p">::</span><span class="n">Address</span><span class="p">,</span>
    <span class="c">/// My normal spending key (note: could be a Clause instead...)</span>
    <span class="n">key</span><span class="p">:</span> <span class="nn">bitcoin</span><span class="p">::</span><span class="n">PublicKey</span><span class="p">,</span>
    <span class="c">/// How long you have to claim you're not dead</span>
    <span class="n">timeout</span><span class="p">:</span> <span class="n">RelTime</span><span class="p">,</span>
    <span class="c">/// Addresses for CPFP Anchor Outputs</span>
    <span class="n">is_dead_cpfp</span><span class="p">:</span> <span class="nn">bitcoin</span><span class="p">::</span><span class="n">Address</span><span class="p">,</span>
    <span class="n">is_live_cpfp</span><span class="p">:</span> <span class="nn">bitcoin</span><span class="p">::</span><span class="n">Address</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">Alive</span> <span class="p">{</span>
    <span class="nd">#[guard]</span>
    <span class="k">fn</span> <span class="nf">is_dead_sig</span><span class="p">(</span><span class="k">self</span><span class="p">,</span> <span class="n">ctx</span><span class="p">:</span> <span class="n">Context</span><span class="p">)</span> <span class="p">{</span>
        <span class="nn">Clause</span><span class="p">::</span><span class="nf">Key</span><span class="p">(</span><span class="k">self</span><span class="py">.is_dead</span><span class="nf">.clone</span><span class="p">())</span>
    <span class="p">}</span>
    <span class="c">/// only allow the is_dead key to transition to a CheckIfDead </span>
    <span class="nd">#[then(guarded_by=</span><span class="s">"[Self::is_dead_sig]"</span><span class="nd">)]</span>
    <span class="k">fn</span> <span class="nf">am_i_dead</span><span class="p">(</span><span class="k">self</span><span class="p">,</span> <span class="n">ctx</span><span class="p">:</span> <span class="n">Context</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">dust</span> <span class="o">=</span> <span class="nn">Amount</span><span class="p">::</span><span class="nf">from_sat</span><span class="p">(</span><span class="mi">600</span><span class="p">);</span>
        <span class="k">let</span> <span class="n">amt</span> <span class="o">=</span> <span class="n">ctx</span><span class="nf">.funds</span><span class="p">();</span>
        <span class="n">ctx</span><span class="nf">.template</span><span class="p">()</span>
            <span class="c">// Send all but some dust to CheckIfDead</span>
            <span class="nf">.add_output</span><span class="p">(</span><span class="n">amt</span> <span class="o">-</span> <span class="n">dust</span><span class="p">,</span> <span class="o">&amp;</span><span class="nf">CheckIfDead</span><span class="p">(</span><span class="k">self</span><span class="nf">.clone</span><span class="p">()),</span> <span class="nb">None</span><span class="p">)</span><span class="o">?</span>
            <span class="c">// used for CPFP</span>
            <span class="nf">.add_output</span><span class="p">(</span>
                <span class="n">dust</span><span class="p">,</span>
                <span class="o">&amp;</span><span class="nn">Compiled</span><span class="p">::</span><span class="nf">from_address</span><span class="p">(</span><span class="k">self</span><span class="py">.is_dead_cpfp</span><span class="nf">.clone</span><span class="p">(),</span> <span class="nb">None</span><span class="p">),</span>
                <span class="nb">None</span><span class="p">,</span>
            <span class="p">)</span><span class="o">?</span>
            <span class="nf">.into</span><span class="p">()</span>
    <span class="p">}</span>
    <span class="c">/// Allow spending like normal</span>
    <span class="nd">#[guard]</span>
    <span class="k">fn</span> <span class="nf">spend</span><span class="p">(</span><span class="k">self</span><span class="p">,</span> <span class="n">ctx</span><span class="p">:</span> <span class="n">Context</span><span class="p">)</span> <span class="p">{</span>
        <span class="nn">Clause</span><span class="p">::</span><span class="nf">Key</span><span class="p">(</span><span class="k">self</span><span class="py">.key</span><span class="nf">.clone</span><span class="p">())</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">Contract</span> <span class="k">for</span> <span class="n">Alive</span> <span class="p">{</span>
    <span class="nd">declare!</span> <span class="p">{</span><span class="n">finish</span><span class="p">,</span> <span class="nn">Self</span><span class="p">::</span><span class="n">spend</span><span class="p">}</span>
    <span class="nd">declare!</span> <span class="p">{</span><span class="n">then</span><span class="p">,</span> <span class="nn">Self</span><span class="p">::</span><span class="n">am_i_dead</span><span class="p">}</span>
<span class="p">}</span>

<span class="c">/// All the info we need is in Alive struct already...</span>
<span class="k">struct</span> <span class="nf">CheckIfDead</span><span class="p">(</span><span class="n">Alive</span><span class="p">);</span>
<span class="k">impl</span> <span class="n">CheckIfDead</span> <span class="p">{</span>
    <span class="c">/// we're dead after the timeout and is_dead key signs to take the money</span>
    <span class="nd">#[guard]</span>
    <span class="k">fn</span> <span class="nf">is_dead</span><span class="p">(</span><span class="k">self</span><span class="p">,</span> <span class="n">ctx</span><span class="p">:</span> <span class="n">Context</span><span class="p">)</span> <span class="p">{</span>
        <span class="nn">Clause</span><span class="p">::</span><span class="nf">And</span><span class="p">(</span><span class="nd">vec!</span><span class="p">[</span><span class="nn">Clause</span><span class="p">::</span><span class="nf">Key</span><span class="p">(</span><span class="k">self</span><span class="na">.0</span><span class="py">.is_dead</span><span class="nf">.clone</span><span class="p">()),</span> <span class="k">self</span><span class="na">.0</span><span class="py">.timeout</span><span class="nf">.clone</span><span class="p">()</span><span class="nf">.into</span><span class="p">()])</span>
    <span class="p">}</span>

    <span class="c">/// signature required for liveness claim</span>
    <span class="nd">#[guard]</span>
    <span class="k">fn</span> <span class="nf">alive_auth</span><span class="p">(</span><span class="k">self</span><span class="p">,</span> <span class="n">ctx</span><span class="p">:</span> <span class="n">Context</span><span class="p">)</span> <span class="p">{</span>
        <span class="nn">Clause</span><span class="p">::</span><span class="nf">Key</span><span class="p">(</span><span class="k">self</span><span class="py">.key</span><span class="nf">.clone</span><span class="p">())</span>
    <span class="p">}</span>
    <span class="c">/// um excuse me i'm actually alive</span>
    <span class="nd">#[then(guarded_by=</span><span class="s">"[Self::alive_auth]"</span><span class="nd">)]</span>
    <span class="k">fn</span> <span class="nf">im_alive</span><span class="p">(</span><span class="k">self</span><span class="p">,</span> <span class="n">ctx</span><span class="p">:</span> <span class="n">Context</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">dust</span> <span class="o">=</span> <span class="nn">Amount</span><span class="p">::</span><span class="nf">from_sat</span><span class="p">(</span><span class="mi">600</span><span class="p">);</span>
        <span class="k">let</span> <span class="n">amt</span> <span class="o">=</span> <span class="n">ctx</span><span class="nf">.funds</span><span class="p">();</span>
        <span class="n">ctx</span><span class="nf">.template</span><span class="p">()</span>
            <span class="c">/// Send funds to the backup address!</span>
            <span class="nf">.add_output</span><span class="p">(</span>
                <span class="n">amt</span> <span class="o">-</span> <span class="n">dust</span><span class="p">,</span>
                <span class="o">&amp;</span><span class="nn">Compiled</span><span class="p">::</span><span class="nf">from_address</span><span class="p">(</span><span class="k">self</span><span class="na">.0</span><span class="py">.is_live</span><span class="nf">.clone</span><span class="p">(),</span> <span class="nb">None</span><span class="p">),</span>
                <span class="nb">None</span><span class="p">,</span>
            <span class="p">)</span><span class="o">?</span>
            <span class="c">/// Dust for CPFP-ing</span>
            <span class="nf">.add_output</span><span class="p">(</span>
                <span class="n">dust</span><span class="p">,</span>
                <span class="o">&amp;</span><span class="nn">Compiled</span><span class="p">::</span><span class="nf">from_address</span><span class="p">(</span><span class="k">self</span><span class="na">.0</span><span class="py">.is_live_cpfp</span><span class="nf">.clone</span><span class="p">(),</span> <span class="nb">None</span><span class="p">),</span>
                <span class="nb">None</span><span class="p">,</span>
            <span class="p">)</span><span class="o">?</span>
            <span class="nf">.into</span><span class="p">()</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">Contract</span> <span class="k">for</span> <span class="n">CheckIfDead</span> <span class="p">{</span>
    <span class="nd">declare!</span> <span class="p">{</span><span class="n">finish</span><span class="p">,</span> <span class="nn">Self</span><span class="p">::</span><span class="n">is_dead</span><span class="p">}</span>
    <span class="nd">declare!</span> <span class="p">{</span><span class="n">then</span><span class="p">,</span> <span class="nn">Self</span><span class="p">::</span><span class="n">im_alive</span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>In this example, the funds start in a state of Alive, until a challenger calls
<code class="language-plaintext highlighter-rouge">Alive::am_i_dead</code> or the original owner spends the coin. After the call of
<code class="language-plaintext highlighter-rouge">Alive::am_i_dead</code>, the contract transitions to CheckIfDead state. From this state,
the owner has <code class="language-plaintext highlighter-rouge">timeout</code> (either time or blocks) time to move the coin to their
key, or else the claimer of the death can spend using <code class="language-plaintext highlighter-rouge">CheckIfDead::is_dead</code>.</p>

<p>Of course, we can clean up this contract in various ways (e.g., making the
destination if dead generic). That could look something like this:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">Alive</span> <span class="p">{</span>
    <span class="n">is_dead_cpfp</span><span class="p">:</span> <span class="nn">bitcoin</span><span class="p">::</span><span class="n">Address</span><span class="p">,</span>
    <span class="n">is_live_cpfp</span><span class="p">:</span> <span class="nn">bitcoin</span><span class="p">::</span><span class="n">Address</span><span class="p">,</span>
    <span class="c">// note that this permits composing Alive with some arbitrary function</span>
    <span class="n">is_dead</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">dyn</span> <span class="nf">Fn</span><span class="p">(</span><span class="n">ctx</span><span class="p">:</span> <span class="n">Context</span><span class="p">,</span> <span class="n">cpfp</span><span class="p">:</span> <span class="nn">bitcoin</span><span class="p">::</span><span class="n">Address</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">TxTmplIt</span><span class="p">,</span>
    <span class="n">is_live</span><span class="p">:</span> <span class="nn">bitcoin</span><span class="p">::</span><span class="n">Address</span><span class="p">,</span>
    <span class="n">key</span><span class="p">:</span> <span class="nn">bitcoin</span><span class="p">::</span><span class="n">PublicKey</span><span class="p">,</span>
    <span class="n">timeout</span><span class="p">:</span> <span class="n">RelTime</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">CheckIfDead</span> <span class="p">{</span>
    <span class="nd">#[then]</span>
    <span class="k">fn</span> <span class="nf">is_dead</span><span class="p">(</span><span class="k">self</span><span class="p">,</span> <span class="n">ctx</span><span class="p">:</span> <span class="n">Context</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">self</span><span class="na">.0</span><span class="nf">.is_dead</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="k">self</span><span class="na">.0</span><span class="py">.is_dead_cpfp</span><span class="nf">.clone</span><span class="p">())</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>This kind of dead man switch is much more reliable than having slowly eroding
timelocks since it doesn’t require regular transaction refreshing, which was the
source of <a href="https://medium.com/blockstream/patching-the-liquid-timelock-issue-b4b2f5f9a973">a bug in Blockstream’s federation
code</a>.
It also requires an explicit action to claim a lack of liveness, which also
gives information about the trustworthiness of your kids (or any exploits of
their signers).</p>

<h2 id="not-so-fast">Not so fast</h2>

<p>What if we want to make sure that little Jimmy and his gambling addiction don’t
blow it all at once… Maybe if instead of giving Jimmy one big lump sum, we
could give a little bit every month. Then maybe he’d be better off! This is
basically an Annuity contract.</p>

<p>Now let’s have a look at an annuity contract.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">Annuity</span> <span class="p">{</span>
    <span class="n">to</span><span class="p">:</span> <span class="nn">bitcoin</span><span class="p">::</span><span class="n">PublicKey</span><span class="p">,</span>
    <span class="n">amount</span><span class="p">:</span> <span class="nn">bitcoin</span><span class="p">::</span><span class="n">Amount</span><span class="p">,</span>
    <span class="n">period</span><span class="p">:</span> <span class="n">AnyRelTime</span>
<span class="p">}</span>

<span class="k">const</span> <span class="n">MIN_PAYOUT</span><span class="p">:</span> <span class="nn">bitcoin</span><span class="p">::</span><span class="n">Amount</span> <span class="o">=</span> <span class="nn">bitcoin</span><span class="p">::</span><span class="nn">Amount</span><span class="p">::</span><span class="nf">from_sat</span><span class="p">(</span><span class="mi">10000</span><span class="p">);</span>
<span class="k">impl</span> <span class="n">Annuity</span> <span class="p">{</span>
    <span class="nd">#[then]</span>
    <span class="k">fn</span> <span class="nf">claim</span><span class="p">(</span><span class="k">self</span><span class="p">,</span> <span class="n">ctx</span><span class="p">:</span><span class="n">Context</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">amt</span> <span class="o">=</span> <span class="n">ctx</span><span class="nf">.funds</span><span class="p">();</span>
        <span class="c">// Basically, while there are funds left this contract recurses to itself,</span>
        <span class="c">// until there's only a little bit left over.</span>
        <span class="c">// No need for CPFP since we can spend from the `to` output for CPFP.</span>
        <span class="k">if</span> <span class="n">amt</span> <span class="o">-</span> <span class="k">self</span><span class="py">.amount</span> <span class="o">&gt;</span> <span class="n">MIN_PAYOUT</span> <span class="p">{</span>
            <span class="n">ctx</span><span class="nf">.template</span><span class="p">()</span>
                <span class="nf">.add_output</span><span class="p">(</span><span class="k">self</span><span class="py">.amount</span><span class="p">,</span> <span class="o">&amp;</span><span class="k">self</span><span class="py">.to</span><span class="p">,</span> <span class="nb">None</span><span class="p">)</span><span class="o">?</span>
                <span class="nf">.add_output</span><span class="p">(</span><span class="n">amt</span> <span class="o">-</span> <span class="k">self</span><span class="py">.amount</span><span class="p">,</span> <span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="nb">None</span><span class="p">)</span><span class="o">?</span>
                <span class="nf">.set_sequence</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="k">self</span><span class="py">.period</span><span class="nf">.into</span><span class="p">())</span><span class="o">?</span>
                <span class="nf">.into</span><span class="p">()</span>
        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="n">amt</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
            <span class="n">ctx</span><span class="nf">.template</span><span class="p">()</span>
                <span class="nf">.add_output</span><span class="p">(</span><span class="n">amt</span><span class="p">,</span> <span class="o">&amp;</span><span class="k">self</span><span class="py">.to</span><span class="p">,</span> <span class="nb">None</span><span class="p">)</span><span class="o">?</span>
                <span class="nf">.set_sequence</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="k">self</span><span class="py">.period</span><span class="nf">.into</span><span class="p">())</span><span class="o">?</span>
                <span class="nf">.into</span><span class="p">()</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="c">// nothing left to claim</span>
            <span class="nf">empty</span><span class="p">()</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

</code></pre></div></div>

<p>We could instead “transpose” an annuity into a non-serialized form. This would
basically be a big transaction that has N outputs with locktimes on claiming
each. However this has a few drawbacks:</p>

<ol>
  <li>
    <p>Claims are non-serialized, which means that relative timelocks can only last
at most 2 years. Therefore only absolute timelocks may be used.</p>
  </li>
  <li>
    <p>You might want to make it possible for another entity to counterclaim Jimmy’s
funds back, perhaps if he also died (talk about bad luck). In the transposed version, you would need to make N proof-of-life challenges v.s. just one<sup id="fnref:recursion" role="doc-noteref"><a href="#fn:recursion" class="footnote" rel="footnote">1</a></sup>.</p>
  </li>
  <li>
    <p>You would have to pay more fees all at once (although less fees overall if feerates increase or stay flat).</p>
  </li>
  <li>
    <p>It’s less extensible – for example, it would be possible to do a lot of cool
things with serialization of payouts (e.g., allowing oracles to inflation adjust
payout rate).</p>
  </li>
</ol>

<h2 id="splits">Splits</h2>

<p>Remember our annoying spouse, bad lawyer, etc? Well, instead of giving them a multisig, imagine
we use the split function as the end output from our CheckIfDead:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="nf">split</span><span class="p">(</span><span class="n">ctx</span><span class="p">:</span> <span class="n">Context</span><span class="p">,</span> <span class="n">cpfp</span><span class="p">:</span> <span class="nn">bitcoin</span><span class="p">::</span><span class="n">Address</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">TxTmplIt</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">dust</span> <span class="o">=</span> <span class="nn">Amount</span><span class="p">::</span><span class="nf">from_sat</span><span class="p">(</span><span class="mi">600</span><span class="p">);</span>
    <span class="k">let</span> <span class="n">amt</span> <span class="o">=</span> <span class="n">ctx</span><span class="nf">.funds</span><span class="p">()</span> <span class="o">-</span> <span class="n">dust</span><span class="p">;</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">ctx</span><span class="nf">.template</span><span class="p">()</span>
       <span class="nf">.add_output</span><span class="p">(</span><span class="n">dust</span><span class="p">,</span> <span class="o">&amp;</span><span class="nn">Compiled</span><span class="p">::</span><span class="nf">from_address</span><span class="p">(</span><span class="n">cpfp</span><span class="p">,</span> <span class="nb">None</span><span class="p">),</span> <span class="nb">None</span><span class="p">)</span><span class="o">?</span>
       <span class="nf">.add_output</span><span class="p">(</span><span class="n">amt</span><span class="o">*</span><span class="mf">0.5</span><span class="p">,</span> <span class="o">&amp;</span><span class="nn">from_somewhere</span><span class="p">::</span><span class="n">spouse_annuity</span><span class="p">,</span> <span class="nb">None</span><span class="p">)</span><span class="o">?</span>
       <span class="nf">.add_output</span><span class="p">(</span><span class="n">amt</span> <span class="o">*</span> <span class="mf">0.1666</span><span class="p">,</span> <span class="o">&amp;</span><span class="nn">from_somewhere</span><span class="p">::</span><span class="n">kids_annuity</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">None</span><span class="p">)</span><span class="o">?</span>
       <span class="nf">.add_output</span><span class="p">(</span><span class="n">amt</span><span class="o">*</span><span class="mf">0.1666</span><span class="p">,</span> <span class="o">&amp;</span><span class="nn">from_somewhere</span><span class="p">::</span><span class="n">kids_annuity</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="nb">None</span><span class="p">)</span><span class="o">?</span>
       <span class="nf">.add_output</span><span class="p">(</span><span class="n">amt</span><span class="o">*</span><span class="mf">0.1666</span><span class="p">,</span> <span class="o">&amp;</span><span class="nn">from_somewhere</span><span class="p">::</span><span class="n">kids_annuity</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="nb">None</span><span class="p">)</span><span class="o">?</span>
       <span class="nf">.into</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div></div>

<p>This way we don’t rely on any pesky disagreement over what to sign, the funds
are split exactly how we like.</p>

<h2 id="oracles-and-lawyers">Oracles and Lawyers</h2>

<p>Lastly, it is possible to bake into these contracts all sorts of
conditionallity.</p>

<p>For example, imagine an Annuity that only makes payouts if a University
Attendance Validator signs your tuition payment, otherwise you get the coins on
your 25th Birthday.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">Tuition</span> <span class="p">{</span>
    <span class="c">/// keep this key secret from the school</span>
    <span class="n">to</span><span class="p">:</span> <span class="nn">bitcoin</span><span class="p">::</span><span class="n">PublicKey</span><span class="p">,</span>
    <span class="n">enrolled</span><span class="p">:</span> <span class="nn">bitcoin</span><span class="p">::</span><span class="n">PublicKey</span><span class="p">,</span>
    <span class="n">school</span><span class="p">:</span> <span class="nn">bitcoin</span><span class="p">::</span><span class="n">PublicKey</span><span class="p">,</span>
    <span class="n">amount</span><span class="p">:</span> <span class="nn">bitcoin</span><span class="p">::</span><span class="n">Amount</span><span class="p">,</span>
    <span class="n">period</span><span class="p">:</span> <span class="n">AnyRelTime</span><span class="p">,</span>
    <span class="n">birthday</span><span class="p">:</span> <span class="n">AbsTime</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">const</span> <span class="n">MIN_PAYOUT</span><span class="p">:</span> <span class="nn">bitcoin</span><span class="p">::</span><span class="n">Amount</span> <span class="o">=</span> <span class="nn">bitcoin</span><span class="p">::</span><span class="nn">Amount</span><span class="p">::</span><span class="nf">from_sat</span><span class="p">(</span><span class="mi">10000</span><span class="p">);</span>
<span class="k">impl</span> <span class="n">Tuition</span> <span class="p">{</span>
    <span class="nd">#[guard]</span>
    <span class="k">fn</span> <span class="nf">enrolled</span><span class="p">(</span><span class="k">self</span><span class="p">,</span> <span class="n">ctx</span><span class="p">:</span> <span class="n">Context</span><span class="p">)</span> <span class="p">{</span>
        <span class="nn">Clause</span><span class="p">::</span><span class="nf">And</span><span class="p">(</span><span class="nd">vec!</span><span class="p">[</span><span class="nn">Clause</span><span class="p">::</span><span class="nf">Key</span><span class="p">(</span><span class="k">self</span><span class="py">.enrolled</span><span class="p">),</span> <span class="nn">Clause</span><span class="p">::</span><span class="nf">Key</span><span class="p">(</span><span class="k">self</span><span class="py">.to</span><span class="p">)])</span>
    <span class="p">}</span>
    <span class="nd">#[then(guarded_by=</span><span class="s">"[Self::enrolled]"</span><span class="nd">)]</span>
    <span class="k">fn</span> <span class="nf">claim</span><span class="p">(</span><span class="k">self</span><span class="p">,</span> <span class="n">ctx</span><span class="p">:</span><span class="n">Context</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">amt</span> <span class="o">=</span> <span class="n">ctx</span><span class="nf">.funds</span><span class="p">();</span>
        <span class="k">if</span> <span class="n">amt</span> <span class="o">-</span> <span class="k">self</span><span class="py">.amount</span> <span class="o">&gt;</span> <span class="n">MIN_PAYOUT</span> <span class="p">{</span>
            <span class="c">// send money to school</span>
            <span class="n">ctx</span><span class="nf">.template</span><span class="p">()</span>
                <span class="nf">.add_output</span><span class="p">(</span><span class="k">self</span><span class="py">.amount</span><span class="p">,</span> <span class="o">&amp;</span><span class="k">self</span><span class="py">.enrolled</span><span class="p">,</span> <span class="nb">None</span><span class="p">)</span><span class="o">?</span>
                <span class="nf">.add_output</span><span class="p">(</span><span class="n">amt</span> <span class="o">-</span> <span class="k">self</span><span class="py">.amount</span><span class="p">,</span> <span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="nb">None</span><span class="p">)</span><span class="o">?</span>
                <span class="nf">.set_sequence</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="k">self</span><span class="py">.period</span><span class="nf">.into</span><span class="p">())</span><span class="o">?</span>
                <span class="nf">.into</span><span class="p">()</span>
        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="n">amt</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
            <span class="c">// give the change to child</span>
            <span class="n">ctx</span><span class="nf">.template</span><span class="p">()</span>
                <span class="nf">.add_output</span><span class="p">(</span><span class="n">amt</span><span class="p">,</span> <span class="o">&amp;</span><span class="k">self</span><span class="py">.to</span><span class="p">,</span> <span class="nb">None</span><span class="p">)</span><span class="o">?</span>
                <span class="nf">.set_sequence</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="k">self</span><span class="py">.period</span><span class="nf">.into</span><span class="p">())</span><span class="o">?</span>
                <span class="nf">.into</span><span class="p">()</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="nf">empty</span><span class="p">()</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="nd">#[guard]</span>
    <span class="k">fn</span> <span class="nf">spend</span><span class="p">(</span><span class="k">self</span><span class="p">,</span> <span class="n">ctx</span><span class="p">:</span> <span class="n">Context</span><span class="p">)</span> <span class="p">{</span>
        <span class="nn">Clause</span><span class="p">::</span><span class="nf">And</span><span class="p">(</span><span class="nd">vec!</span><span class="p">[</span><span class="k">self</span><span class="py">.birthday</span><span class="nf">.into</span><span class="p">(),</span> <span class="nn">Clause</span><span class="p">::</span><span class="nf">Key</span><span class="p">(</span><span class="k">self</span><span class="py">.to</span><span class="p">)])</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The oracle can’t really steal funds here – they can only sign the already
agreed on txn and get the tuition payment to the “school” network. And on the
specified Birthday, if not used for tuition, the funds go to the child directly.</p>

<h1 id="where-do-these-live">Where do these live?</h1>

<p>In theory what you’d end up doing is attaching these to every coin in you wallet
under a dead-man switch.</p>

<p>Ideally, you’d put enough under your main “structured” splits that you’re not
moving all to often and then you would have the rest go into less structured
stuff.  E.g., the college fund coins you might touch less frequently than the
coins for general annuity. You can also sequence some things using absolute
timelocks, for example.</p>

<p>In an ideal world you would have a wallet agent that is aware of all your UTXOs
and your will and testament state and makes sure to regenerate the correct
conditions whenever you spend and then store them durably, but that’s a bit
futuristic for the time being.  With CTV the story is a bit better, as for many
designs you could distribute a WASM bundle for your wallet to your family and
they could use that to generate all the transactions given an output, without
needing to have every presigned transaction saved.</p>

<p>This does demonstrate a relative strength for the account model, it’s much
easier to keep all your funds in once account and write globally correct
inheritence vault logic around it for all your funds, computed across
percentages. No matter the UTXO model covenant, that someone might have multiple
UTXOs poses an inherent challenge in doing this kind of stuff properly.</p>

<h1 id="what-else">What else?</h1>

<p>Well, this is just a small sampling of things you could do. Part of the power of
Sapio is that I hope you’re feeling inspired to make your own bespoke
inhertience scheme in it! No one size fits all, ever, but perhaps with the power
of Sapio available to the world we’ll see a lot more experimentation with what’s
possible.</p>

<hr />

<p>Till next time – Jeremy.</p>
<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:recursion" role="doc-endnote">
      <p>Note this is a case where unrolling can be used, but the contract sizes can blow up kinda quick, so careful programming might be needed or you might need to say that it can only be claimed that Jimmy is dead once or twice before he just gets all the money. Recursive covenants would not nescessarily have this issue. <a href="#fnref:recursion" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>

  </div>
<hr>
  
<hr>
  <div class="post">
    <h2 class="post-title">
        <a href="/bitcoin/2021/12/07/advent-10/">
        Building Vaults on Bitcoin
      </a>
  </h2>
  <h4>Day 10: Rubin's Bitcoin Advent Calendar</h4>


    <span class="post-date">07 Dec 2021</span>

    <p><em>Welcome to day 10 of my Bitcoin Advent Calendar. You can see an index of all
the posts <a href="/advent21">here</a> or subscribe at
<a href="https://judica.org/join">judica.org/join</a> to get new posts in your inbox</em></p>

<p>A “Vault” is a general concept for a way of protecting Bitcoin from theft
through a cold-storage smart contract. While there is not formal definition of
what is and is not a Vault, generally a Vault has more structure around a
withdrawal than just a multisig.</p>

<p>One of the earlier
<a href="https://hackingdistributed.com/2016/02/26/how-to-implement-secure-bitcoin-vaults/">references</a>
for Vaults was a design whereby every time you request to withdraw from it you
can “reset” the request within a time limit.  This means that while an attacker
might steal your keys, you can “fight” to make it a negative sum game – e.g.,
they’ll just keep on paying fees to eventually steal an amount less than they
paid. This might serve to disincentivize hacking exchanges if hackers are less
likely to actually get coins.</p>

<p>Similar Vaults can be built using Sapio, but the logic for them involves
unrolling the contract a predefined number of steps. This isn’t bad because if
the period of timeout is 1 week then just unrolling 5,200 times gets you one
thousand years of hacking disincentive.</p>

<p>The contract for that might look something like this in Sapio (<em>note: I was
running behind on this post so I may make modifications to make these examples
better later</em>):</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">VaultOne</span> <span class="p">{</span>
    <span class="c">/// Key that will authorize:</span>
    <span class="c">/// 1) Recursing with the vault</span>
    <span class="c">/// 2) Spending from the vault after not moved for a period</span>
    <span class="n">key</span><span class="p">:</span> <span class="nn">bitcoin</span><span class="p">::</span><span class="n">PublicKey</span><span class="p">,</span>
    <span class="c">/// How long should the vault live for</span>
    <span class="n">steps</span><span class="p">:</span> <span class="nb">u32</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">VaultOne</span> <span class="p">{</span>
    <span class="c">/// Checks if steps are remaining</span>
    <span class="nd">#[compile_if]</span>
    <span class="k">fn</span> <span class="nf">not_out_of_steps</span><span class="p">(</span><span class="k">self</span><span class="p">,</span> <span class="n">ctx</span><span class="p">:</span> <span class="n">Context</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="k">self</span><span class="py">.steps</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
            <span class="nn">ConditionalCompileType</span><span class="p">::</span><span class="n">Never</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="nn">ConditionalCompileType</span><span class="p">::</span><span class="n">NoConstraint</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="nd">#[guard]</span>
    <span class="k">fn</span> <span class="nf">authorize</span><span class="p">(</span><span class="k">self</span><span class="p">,</span> <span class="n">ctx</span><span class="p">:</span> <span class="n">Context</span><span class="p">)</span> <span class="p">{</span>
        <span class="nn">Clause</span><span class="p">::</span><span class="nf">Key</span><span class="p">(</span><span class="k">self</span><span class="py">.key</span><span class="nf">.clone</span><span class="p">())</span>
    <span class="p">}</span>

    <span class="c">/// Recurses the vault if authorized</span>
    <span class="nd">#[then(compile_if</span> <span class="nd">=</span> <span class="s">"[Self::not_out_of_steps]"</span><span class="nd">,</span> <span class="nd">guarded_by</span> <span class="nd">=</span> <span class="s">"[Self::authorize]"</span><span class="nd">)]</span>
    <span class="k">fn</span> <span class="nf">step</span><span class="p">(</span><span class="k">self</span><span class="p">,</span> <span class="n">ctx</span><span class="p">:</span> <span class="n">Context</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">next</span> <span class="o">=</span> <span class="n">VaultOne</span> <span class="p">{</span>
            <span class="n">key</span><span class="p">:</span> <span class="k">self</span><span class="py">.key</span><span class="nf">.clone</span><span class="p">(),</span>
            <span class="n">steps</span><span class="p">:</span> <span class="k">self</span><span class="py">.steps</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
        <span class="p">};</span>
        <span class="k">let</span> <span class="n">amt</span> <span class="o">=</span> <span class="n">ctx</span><span class="nf">.funds</span><span class="p">();</span>
        <span class="n">ctx</span><span class="nf">.template</span><span class="p">()</span>
            <span class="nf">.add_output</span><span class="p">(</span><span class="n">amt</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">next</span><span class="p">,</span> <span class="nb">None</span><span class="p">)</span><span class="o">?</span>
            <span class="c">// For Paying fees via CPFP. Note that we should totally definitely</span>
            <span class="c">// get rid of the dust limit for contracts like this, or enable</span>
            <span class="c">// IUTXOS with 0 Value</span>
            <span class="nf">.add_output</span><span class="p">(</span><span class="nn">Amount</span><span class="p">::</span><span class="nf">from_sat</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="o">&amp;</span><span class="k">self</span><span class="py">.key</span><span class="p">,</span> <span class="nb">None</span><span class="p">)</span><span class="o">?</span>
            <span class="nf">.into</span><span class="p">()</span>
    <span class="p">}</span>
    <span class="c">/// Allow spending after a week long delay</span>
    <span class="nd">#[guard]</span>
    <span class="k">fn</span> <span class="nf">finish</span><span class="p">(</span><span class="k">self</span><span class="p">,</span> <span class="n">ctx</span><span class="p">:</span> <span class="n">Context</span><span class="p">)</span> <span class="p">{</span>
        <span class="nn">Clause</span><span class="p">::</span><span class="nf">And</span><span class="p">(</span><span class="nd">vec!</span><span class="p">[</span>
            <span class="nn">Clause</span><span class="p">::</span><span class="nf">Key</span><span class="p">(</span><span class="k">self</span><span class="py">.key</span><span class="nf">.clone</span><span class="p">()),</span>
            <span class="nn">RelTime</span><span class="p">::</span><span class="nf">try_from</span><span class="p">(</span><span class="nn">Duration</span><span class="p">::</span><span class="nf">from_secs</span><span class="p">(</span><span class="mi">7</span> <span class="o">*</span> <span class="mi">24</span> <span class="o">*</span> <span class="mi">60</span> <span class="o">*</span> <span class="mi">60</span><span class="p">))</span>
                <span class="nf">.unwrap</span><span class="p">()</span>
                <span class="nf">.into</span><span class="p">(),</span>
        <span class="p">])</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="c">/// Binds the logic to the Contract</span>
<span class="k">impl</span> <span class="n">Contract</span> <span class="k">for</span> <span class="n">VaultOne</span> <span class="p">{</span>
    <span class="nd">declare!</span> <span class="p">{</span><span class="n">then</span><span class="p">,</span> <span class="nn">Self</span><span class="p">::</span><span class="n">step</span><span class="p">}</span>
    <span class="nd">declare!</span> <span class="p">{</span><span class="n">finish</span><span class="p">,</span> <span class="nn">Self</span><span class="p">::</span><span class="n">finish</span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>But we can also build much more sophisticated Vaults that do more. Suppose we
want to have a vault where once a week you can claim a trickle of bitcoin into a
hot wallet, or you can send it back to a cold storage key. This is a “structured
liquidity vault” that gives you time-release Bitcoin. Let’s check out some code
and talk about it more:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">#[derive(Clone)]</span>
<span class="k">struct</span> <span class="n">VaultTwo</span> <span class="p">{</span>
    <span class="c">/// Key just for authorizing steps</span>
    <span class="n">authorize_key</span><span class="p">:</span> <span class="nn">bitcoin</span><span class="p">::</span><span class="n">PublicKey</span><span class="p">,</span>
    <span class="n">amount_per_step</span><span class="p">:</span> <span class="nn">bitcoin</span><span class="p">::</span><span class="n">Amount</span><span class="p">,</span>
    <span class="c">/// Hot wallet key</span>
    <span class="n">hot_key</span><span class="p">:</span> <span class="nn">bitcoin</span><span class="p">::</span><span class="n">PublicKey</span><span class="p">,</span>
    <span class="c">/// Cold wallet key</span>
    <span class="n">cold_key</span><span class="p">:</span> <span class="nn">bitcoin</span><span class="p">::</span><span class="n">PublicKey</span><span class="p">,</span>
    <span class="n">steps</span><span class="p">:</span> <span class="nb">u32</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">VaultTwo</span> <span class="p">{</span>
    <span class="nd">#[compile_if]</span>
    <span class="k">fn</span> <span class="nf">not_out_of_steps</span><span class="p">(</span><span class="k">self</span><span class="p">,</span> <span class="n">ctx</span><span class="p">:</span> <span class="n">Context</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="k">self</span><span class="py">.steps</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
            <span class="nn">ConditionalCompileType</span><span class="p">::</span><span class="n">Never</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="nn">ConditionalCompileType</span><span class="p">::</span><span class="n">NoConstraint</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="nd">#[guard]</span>
    <span class="k">fn</span> <span class="nf">authorized</span><span class="p">(</span><span class="k">self</span><span class="p">,</span> <span class="n">ctx</span><span class="p">:</span> <span class="n">Context</span><span class="p">)</span> <span class="p">{</span>
        <span class="nn">Clause</span><span class="p">::</span><span class="nf">Key</span><span class="p">(</span><span class="k">self</span><span class="py">.authorize_key</span><span class="nf">.clone</span><span class="p">())</span>
    <span class="p">}</span>
    <span class="nd">#[then(compile_if</span> <span class="nd">=</span> <span class="s">"[Self::not_out_of_steps]"</span><span class="nd">,</span> <span class="nd">guarded_by</span> <span class="nd">=</span> <span class="s">"[Self::authorized]"</span><span class="nd">)]</span>
    <span class="k">fn</span> <span class="nf">step</span><span class="p">(</span><span class="k">self</span><span class="p">,</span> <span class="n">ctx</span><span class="p">:</span> <span class="n">Context</span><span class="p">)</span> <span class="p">{</span>
        <span class="c">// Creates a recursive vault with one fewer steps</span>
        <span class="k">let</span> <span class="n">next</span> <span class="o">=</span> <span class="n">VaultTwo</span> <span class="p">{</span>
            <span class="n">steps</span><span class="p">:</span> <span class="k">self</span><span class="py">.steps</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
            <span class="o">..</span><span class="k">self</span><span class="nf">.clone</span><span class="p">()</span>
        <span class="p">};</span>
        <span class="k">let</span> <span class="n">amt</span> <span class="o">=</span> <span class="n">ctx</span><span class="nf">.funds</span><span class="p">();</span>
        <span class="n">ctx</span><span class="nf">.template</span><span class="p">()</span>
            <span class="c">// send to the new vault</span>
            <span class="nf">.add_output</span><span class="p">(</span><span class="n">amt</span> <span class="o">-</span> <span class="k">self</span><span class="py">.amount_per_step</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">next</span><span class="p">,</span> <span class="nb">None</span><span class="p">)</span><span class="o">?</span>
            <span class="c">// withdraw some to hot storage</span>
            <span class="nf">.add_output</span><span class="p">(</span><span class="k">self</span><span class="py">.amount_per_step</span><span class="p">,</span> <span class="o">&amp;</span><span class="k">self</span><span class="py">.hot_key</span><span class="p">,</span> <span class="nb">None</span><span class="p">)</span><span class="o">?</span>
            <span class="c">// For Paying fees via CPFP. Note that we should totally definitely</span>
            <span class="c">// get rid of the dust limit for contracts like this, or enable</span>
            <span class="c">// IUTXOS with 0 Value</span>
            <span class="nf">.add_output</span><span class="p">(</span><span class="nn">Amount</span><span class="p">::</span><span class="nf">from_sat</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="o">&amp;</span><span class="k">self</span><span class="py">.authorize_key</span><span class="p">,</span> <span class="nb">None</span><span class="p">)</span><span class="o">?</span>
            <span class="c">// restrict that we have to wait a week</span>
            <span class="nf">.set_sequence</span><span class="p">(</span>
                <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
                <span class="nn">RelTime</span><span class="p">::</span><span class="nf">try_from</span><span class="p">(</span><span class="nn">Duration</span><span class="p">::</span><span class="nf">from_secs</span><span class="p">(</span><span class="mi">7</span> <span class="o">*</span> <span class="mi">24</span> <span class="o">*</span> <span class="mi">60</span> <span class="o">*</span> <span class="mi">60</span><span class="p">))</span><span class="o">?</span><span class="nf">.into</span><span class="p">(),</span>
            <span class="p">)</span><span class="o">?</span>
            <span class="nf">.into</span><span class="p">()</span>
    <span class="p">}</span>
    <span class="c">/// allow sending the remaining funds into cold storage</span>
    <span class="nd">#[then(compile_if</span> <span class="nd">=</span> <span class="s">"[Self::not_out_of_steps]"</span><span class="nd">,</span> <span class="nd">guarded_by</span> <span class="nd">=</span> <span class="s">"[Self::authorized]"</span><span class="nd">)]</span>
    <span class="k">fn</span> <span class="nf">terminate</span><span class="p">(</span><span class="k">self</span><span class="p">,</span> <span class="n">ctx</span><span class="p">:</span> <span class="n">Context</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">ctx</span><span class="nf">.template</span><span class="p">()</span>
            <span class="c">// send the remaining funds to cold storage</span>
            <span class="nf">.add_output</span><span class="p">(</span><span class="k">self</span><span class="py">.amount_per_step</span><span class="o">*</span><span class="k">self</span><span class="py">.steps</span><span class="p">,</span> <span class="o">&amp;</span><span class="k">self</span><span class="py">.cold_key</span><span class="p">,</span> <span class="nb">None</span><span class="p">)</span><span class="o">?</span>
            <span class="c">// For Paying fees via CPFP. Note that we should totally definitely</span>
            <span class="c">// get rid of the dust limit for contracts like this, or enable</span>
            <span class="c">// IUTXOS with 0 Value</span>
            <span class="nf">.add_output</span><span class="p">(</span><span class="nn">Amount</span><span class="p">::</span><span class="nf">from_sat</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="o">&amp;</span><span class="k">self</span><span class="py">.authorize_key</span><span class="p">,</span> <span class="nb">None</span><span class="p">)</span><span class="o">?</span>
            <span class="nf">.into</span><span class="p">()</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">Contract</span> <span class="k">for</span> <span class="n">VaultTwo</span> <span class="p">{</span>
    <span class="nd">declare!</span> <span class="p">{</span><span class="n">then</span><span class="p">,</span> <span class="nn">Self</span><span class="p">::</span><span class="n">step</span><span class="p">,</span> <span class="nn">Self</span><span class="p">::</span><span class="n">terminate</span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>This type of Vault is particularly interesting for e.g., withdrawing from an
exchange business.  Imagine a user, Elsa who wants to have a great cold storage
system. So Elsa sets up a xpub key and puts it on ice. She then generates a new
address, and requests that the exchange let the funds go to it. Later that
month, Elsa wants to buy a coffee with her Bitcoin so she has to thaw out her
cold storage to spend (maybe using a offline PSBT signing), and transfer the
funds to her destination or to a hot wallet if she wants a bit of extra pocket
money. Instead suppose Elsa sets up a timerelease vault. Then, she can set up
her cold vault and automatically be able to claim 1 Bitcoin a month out of it,
or if she notices some coins missing from her hot wallet redirect the funds
solely under her ice castle.</p>

<p>This has many benefits for an average user. One is that you can invest in your
cold storage of keys <em>once</em> in your life and only have to access it in
unexpected circumstance. This means that: users might elect to use something
more secure/inconvenient to access (e.g. strongly geo-sharded); that they won’t
reveal access patterns by visiting their key storage facility; and that they
don’t need to expose themselves to recurring fat-finger<sup id="fnref:fat" role="doc-noteref"><a href="#fn:fat" class="footnote" rel="footnote">1</a></sup> risk.</p>

<h2 id="getting-a-little-more-advanced">Getting a little more advanced</h2>

<p>What are some other things we might want to do in a vault?  Let’s do a quickfire
– we won’t code these here, but you’ll see examples of these techniques in
posts to come:</p>

<h3 id="send-a-percentage-not-a-fixed-amount">Send a percentage, not a fixed amount</h3>

<p>Let the contract know the intended amount, and then compute the withdrawals as
percentages in the program.</p>

<h3 id="non-key-destinations">Non-Key Destinations</h3>
<p>In the examples above, we use keys for hot wallet, cold wallet, and authorizations.</p>

<p>However, we could very well use other programs! For example, imagine a
time-release vault that goes into a anti-theft locker.</p>

<h3 id="change-hot-wallet-every-step">Change Hot Wallet Every Step</h3>

<p>This one is pretty simple – if you have N steps just provide a list of N
different destinations and use the i-th one as you go!</p>

<h3 id="topping-up">Topping up:</h3>

<p>There are advanced techniques that can be used to allow depositing <em>into</em> a
vault after it has been created (i.e., topping up), but that’s too advanced to
go into detail today. For those inclined, a small hint: make the “top up” vault
consume an output from the previous vault, CTV commits to the script so you can
use a salted P2SH out.</p>

<h2 id="even-more-advanced">Even more advanced</h2>

<p>What if we want to ensure that after a withdraw funds are re-inserted into the Vault?</p>

<p>We’ll ditch the recursion (for now), and just look at some basic logic. Imagine
a coin is held by a cold storage key, and we want to use Sapio to generate a transaction
that withdraws funds to an address and sends the rest back into cold storage.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">VaultThree</span> <span class="p">{</span>
    <span class="n">key</span><span class="p">:</span> <span class="nn">bitcoin</span><span class="p">::</span><span class="n">PublicKey</span><span class="p">,</span>
<span class="p">}</span>

<span class="c">/// Special struct for passing arguments to a created contract</span>
<span class="k">enum</span> <span class="n">Withdrawal</span> <span class="p">{</span>
    <span class="nb">Send</span> <span class="p">{</span>
        <span class="n">addr</span><span class="p">:</span> <span class="nn">bitcoin</span><span class="p">::</span><span class="n">Address</span><span class="p">,</span>
        <span class="n">amount</span><span class="p">:</span> <span class="nn">bitcoin</span><span class="p">::</span><span class="n">Amount</span><span class="p">,</span>
        <span class="n">fees</span><span class="p">:</span> <span class="nn">bitcoin</span><span class="p">::</span><span class="n">Amount</span><span class="p">,</span>
    <span class="p">},</span>
    <span class="n">Nothing</span><span class="p">,</span>
<span class="p">}</span>
<span class="c">/// required...</span>
<span class="k">impl</span> <span class="n">Default</span> <span class="k">for</span> <span class="n">Withdrawal</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">default</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="n">Self</span> <span class="p">{</span>
        <span class="nn">Withdrawal</span><span class="p">::</span><span class="n">Nothing</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="k">impl</span> <span class="n">StatefulArgumentsTrait</span> <span class="k">for</span> <span class="n">Withdrawal</span> <span class="p">{}</span>

<span class="c">/// helper for rust type system issue</span>
<span class="k">fn</span> <span class="nf">default_coerce</span><span class="p">(</span>
    <span class="n">k</span><span class="p">:</span> <span class="o">&lt;</span><span class="n">VaultThree</span> <span class="k">as</span> <span class="n">Contract</span><span class="o">&gt;</span><span class="p">::</span><span class="n">StatefulArguments</span><span class="p">,</span>
<span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Result</span><span class="o">&lt;</span><span class="n">Withdrawal</span><span class="p">,</span> <span class="n">CompilationError</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="nf">Ok</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">VaultThree</span> <span class="p">{</span>
    <span class="nd">#[guard]</span>
    <span class="k">fn</span> <span class="nf">signed</span><span class="p">(</span><span class="k">self</span><span class="p">,</span> <span class="n">ctx</span><span class="p">:</span> <span class="n">Context</span><span class="p">)</span> <span class="p">{</span>
        <span class="nn">Clause</span><span class="p">::</span><span class="nf">Key</span><span class="p">(</span><span class="k">self</span><span class="py">.key</span><span class="nf">.clone</span><span class="p">())</span>
    <span class="p">}</span>
    <span class="nd">#[continuation(guarded_by</span> <span class="nd">=</span> <span class="s">"[Self::signed]"</span><span class="nd">,</span> <span class="nd">coerce_args</span> <span class="nd">=</span> <span class="s">"default_coerce"</span><span class="nd">)]</span>
    <span class="k">fn</span> <span class="nf">withdraw</span><span class="p">(</span><span class="k">self</span><span class="p">,</span> <span class="n">ctx</span><span class="p">:</span> <span class="n">Context</span><span class="p">,</span> <span class="n">request</span><span class="p">:</span> <span class="n">Withdrawal</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="k">let</span> <span class="nn">Withdrawal</span><span class="p">::</span><span class="nb">Send</span> <span class="p">{</span> <span class="n">amount</span><span class="p">,</span> <span class="n">fees</span><span class="p">,</span> <span class="n">addr</span> <span class="p">}</span> <span class="o">=</span> <span class="n">request</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">amt</span> <span class="o">=</span> <span class="n">ctx</span><span class="nf">.funds</span><span class="p">();</span>
            <span class="n">ctx</span><span class="nf">.template</span><span class="p">()</span>
                <span class="c">// send the rest recursively to this contract</span>
                <span class="nf">.add_output</span><span class="p">(</span><span class="n">amt</span> <span class="o">-</span> <span class="n">amount</span> <span class="o">-</span> <span class="n">fees</span><span class="p">,</span> <span class="k">self</span><span class="p">,</span> <span class="nb">None</span><span class="p">)</span><span class="o">?</span>
                <span class="c">// process the withdrawal</span>
                <span class="nf">.add_output</span><span class="p">(</span><span class="n">amount</span><span class="p">,</span> <span class="o">&amp;</span><span class="nn">Compiled</span><span class="p">::</span><span class="nf">from_address</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="nb">None</span><span class="p">),</span> <span class="nb">None</span><span class="p">)</span><span class="o">?</span>
                <span class="c">// mark fees as spent</span>
                <span class="nf">.spend_amount</span><span class="p">(</span><span class="n">fees</span><span class="p">)</span><span class="o">?</span>
                <span class="nf">.into</span><span class="p">()</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="nf">empty</span><span class="p">()</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="k">impl</span> <span class="n">Contract</span> <span class="k">for</span> <span class="n">VaultThree</span> <span class="p">{</span>
    <span class="nd">declare!</span> <span class="p">{</span><span class="n">updatable</span><span class="o">&lt;</span><span class="n">Withdrawal</span><span class="o">&gt;</span><span class="p">,</span> <span class="nn">Self</span><span class="p">::</span><span class="n">withdraw</span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<p>Now we’ve seen how updatable continuation clauses can be used to dynamically
pass arguments to a Sapio contract and let the module figure out what the next
transactions should be, managing recursive and non-enumerated state transitions
(albeit with a trust model).</p>

<hr />

<p>That’s probably enough for today, before I make your head explode. We’ll see more examples soon!</p>

<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:fat" role="doc-endnote">
      <p>Sending the wrong amount because you click the wrong key with your too-large hands. <a href="#fnref:fat" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>

  </div>
<hr>
  
<hr>
  <div class="post">
    <h2 class="post-title">
        <a href="/bitcoin/2021/12/06/advent-9/">
        Sapio Primer
      </a>
  </h2>
  <h4>Day 9: Rubin's Bitcoin Advent Calendar</h4>


    <span class="post-date">06 Dec 2021</span>

    <p><em>Welcome to day 9 of my Bitcoin Advent Calendar. You can see an index of all
the posts <a href="/advent21">here</a> or subscribe at
<a href="https://judica.org/join">judica.org/join</a> to get new posts in your inbox</em></p>

<p>We’re through the basics sections of the Advent calendar ow! Time for some more…
specific content on the bleeding edge!</p>

<p>This post is your introduction to the world of
<a href="https://learn.sapio-lang.org">Sapio</a>. Sapio is the programming framework I’ve
been developing for Bitcoin Smart Contracts. There’s a <em>ton</em> of material on <a href="https://learn.sapio-lang.org">the
website</a>, so this post is going to be a bit
high-level and then you should jump into the docs after to learn more.</p>

<h2 id="what-the-heck-is-sapio">What the heck is Sapio?</h2>

<p>Sapio is a tool that helps you design and use Bitcoin smart contracts based on
covenants (like CTV) as well as manage potentially recursive state transitions
at terminal states.</p>

<p>That’s a mouthful and a half… let’s break it down with a very basic vault
deposit example.</p>

<p>Suppose I have 10 bitcoin sitting in my normal wallet.  I want to deposit it to
an exchange. I go to my exchange and request an address to deposit to. The
exchange wants their coins to be in a special cold storage whereby any move from
cold storage has to “mature” for 10 days since it was claimed before it’s
spendable as a hot-spend, otherwise it stays in cold.  The hot wallet has logic
such that any unused funds after it transacts, goes back into the cold-storage
contract. We saw a contract like this in the  <a href="/bitcoin/2021/12/04/advent-7/">day
7</a> post.</p>

<p>The exchange can use Sapio to generate an address that expects 10 coins and
encodes this cold-to-hot logic without requiring the cold keys be online! Better
than that, I don’t even have to contact the exchange for the address. The
exchange can distribute a codesigned Sapio WASM applet that runs on my own
machine locally. I download the applet into my Sapio Studio GUI and that
generates the exchange deposit UX form for the contract that I (or my wallet)
automatically fills out and then generates a proper address/spending
transaction.</p>

<p>Upon receipt of the deposit information, (which can in certain circumstances be
completely on-chain in the txn, so no need for a separate communication
channel), the exchange can us the WASM to generate an identical deposit program
to verify the user isn’t cheating somehow. <strong>Bada-bing-bada-boom!</strong></p>

<p>We’ll see in close detail examples like this coming in the following posts, but
to sum up, Sapio helped us with the following:</p>

<ol>
  <li>Authoring a Smart Contract Application for a cold storage deposit solution</li>
  <li>Distributing it as a deterministic executable with a GUI User using it to make a
deposit</li>
  <li>Receiving funds as a depositee directly into a smart contract</li>
  <li>Generating withdrawal transactions out of the vault</li>
  <li>Putting the remaining funds back into the cold storage</li>
</ol>

<p>This is not a hypothetical, all of these components exist and are usable today!
Where there is an asterisk is that BIP-119 CTV does not yet exist, and so for
apps like this the exchange would have to run some kind of <a href="https://learn.sapio-lang.org/ch05-01-ctv-emulator.html">signing
server</a> you connect to.
This works, but is a worse trust model.  For some applications, you don’t need
CTV if you can get all of a contract’s parties to run their own oracles.
Therefore you can still accomplish a lot without a worse trust model with what’s
there today!</p>
<hr />

<p>Over the remaining posts we’ll go into great detail on different applications
built in Sapio, but for now you can <a href="https://learn.sapio-lang.org">skim through
learn.sapio-lang.org</a> to get started playing
around with your own designs.</p>

  </div>
<hr>
  
</div>

<div class="pagination">
  
    <a class="pagination-item newer" href="/blog/page/4/">Newer</a>
  
  
  <a class="pagination-item older" href="/blog/page/6/">Older</a>
  
</div>

</div>

        </div>
        <div class="content container" style="padding-bottom:0;padding-top:0;bottom:0px;">
            <div class="posts" style="height:14pt;margin-bottom:0;">
                <div class="post">
                    <p style="text-align:center;font-size:12pt;">&copy; 2011-2021 Jeremy Rubin. All rights reserved.</p>
                </div>
            </div>
        </div>
    </body>
</html>
