<!DOCTYPE html>
<html lang="en-us">
    <head>
  <title> Blog (page 2) &middot; Jeremy Rubin </title>
  <link href="https://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">

  <!-- Enable responsiveness on mobile devices-->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">


  <!-- CSS -->
  <link rel="stylesheet" href="/public/css/poole.css">
  <link rel="stylesheet" href="/public/css/syntax.css">
  <link rel="stylesheet" href="/public/css/hyde.css">
  <link rel="stylesheet" href="/public/font-awesome-4.5.0/css/font-awesome.min.css">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=PT+Sans:400,400italic,700|Abril+Fatface">
  <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>

  <!-- Icons -->
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/public/apple-touch-icon-144-precomposed.png">
                                 <link rel="shortcut icon" href="/public/favicon.ico">

  <!-- RSS -->
  <link rel="alternate" type="application/rss+xml" title="RSS" href="/atom.xml">

  
  <link type="application/atom+xml" rel="alternate" href="http://rubin.io/feed.xml" title="Jeremy Rubin" />


  <!-- GA -->
<script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
    ga('create', 'UA-40376251-1', 'auto');
    ga('send', 'pageview');
</script>

  
  <link rel="me" href="https://twitter.com/JeremyRubin" >
  <meta name="twitter:dnt" content="on">
			   <script>window.twttr = (function(d, s, id) {
  var js, fjs = d.getElementsByTagName(s)[0],
    t = window.twttr || {};
  if (d.getElementById(id)) return t;
  js = d.createElement(s);
  js.id = id;
  js.src = "https://platform.twitter.com/widgets.js";
  fjs.parentNode.insertBefore(js, fjs);

  t._e = [];
  t.ready = function(f) {
    t._e.push(f);
  };

  return t;
}(document, "script", "twitter-wjs"));</script>

</head>

    <body>
        <div class="sidebar">
    <h3 style="text-align: center;"> <a href="/"> Jeremy Rubin </a> </h3>
    <div class="container">
        <div class="sidebar-about">

            <div class="sidebar-about-info"> 
                <a href="/public/pdfs/resume.pdf"><i class="fa fa-file-text-o" title=Resume></i></a>
                <a href=""><i class="fa fa-github" title=Github></i></a>
                <a href="https://twitter.com/JeremyRubin"><i class="fa fa-twitter" title=Twitter></i></a>
            </div>
            <div class="sidebar-about-info hide-large">
                <a class="" href="/">Home</a>
                <a class="" href="/blog/">Blog</a>
                <a class="" href="/talks/">Talks</a> 
                <a class="" href="/projects/">Projects</a>
                <a class="" href="/archive/">Site Index</a>
            </div>
        </div>




        <nav class="sidebar-nav hide-small">
            <a class="sidebar-nav-item" href="/">Home</a>
            <a class="sidebar-nav-item" href="/blog/">Blog</a>
            <a class="sidebar-nav-item" href="/talks/">Talks</a> 
            <a class="sidebar-nav-item" href="/projects/">Projects</a>
            <a class="sidebar-nav-item" href="/archive/">Site Index</a>
        </nav>
    </div>
</div>



        <div class="content container" style="padding-bottom:0;">
            <div class="page">
    
    
    <h1>
  Jeremy Rubin's Blog
</h1>

Here you'll find an assorted mix of content from yours truly. I post about a lot
of things, but primarily <a href="/bitcoin/">Bitcoin</a>.

<p>
categories: <a href="/bitcoin/">Bitcoin</a>, <a href="/shenzhen/">Shenzhen Journey</a>.
</p>
<div class="posts">
  
<hr>
  <div class="post">
    <h2 class="post-title">
        <a href="/bitcoin/2022/03/04/london-tutorial/">
        London Advancing Bitcoin Tutorial
      </a>
  </h2>
  <h4>Content for Following Along!</h4>


    <span class="post-date">04 Mar 2022</span>

    <p>Other people have followed this tutorial with some success:</p>

<p>https://gnusha.org/ctv-bip-review/2022-02-22.log</p>

<p>If you’re having a problem, see above log where people have had issues. Common problems include:</p>

<ol>
  <li>Not building latest sapio binary</li>
  <li>Not having the correct clang version (&gt;=12)</li>
  <li>brew installing clang somewhere else (try /opt/homebrew, but also /usr/local/Cellar)</li>
  <li>xargs not liking something (working to debug it, you can open the JSONs with vi and do by hand some of the steps).</li>
</ol>

<hr />

<ol>
  <li>Install JQ (json manipulating tool) if you don’t have it / other things
needed to run a bitcoin node.</li>
  <li>Set up a signet node.</li>
</ol>

<p>Build this branch https://github.com/JeremyRubin/bitcoin/tree/checktemplateverify-signet-23.0-alpha</p>

<p>You’ll likely want settings like this in
   your bitcoin.conf too:</p>
<div class="language-toml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nn">[signet]</span>
<span class="c"># generate this yourself                                                                                                                    rpcauth=generateme:fromtherpcauth.pyfile     </span>
<span class="py">txindex</span><span class="p">=</span><span class="mi">1</span>
<span class="py">signetchallenge</span><span class="p">=</span><span class="mf">512102946e8</span><span class="err">ba</span><span class="mi">8</span><span class="err">eca</span><span class="mf">597194e7</span><span class="err">ed</span><span class="mi">90377</span><span class="err">d</span><span class="mi">9</span><span class="err">bbebc</span><span class="mi">5</span><span class="err">d</span><span class="mi">17</span><span class="err">a</span><span class="mi">9609</span><span class="err">ab</span><span class="mf">3e35</span><span class="err">e</span><span class="mi">706612</span><span class="err">ee</span><span class="mi">882759351</span><span class="err">ae</span> 
<span class="err">rpcport=</span><span class="mi">18332</span>
<span class="py">rpcworkqueue</span><span class="p">=</span><span class="mi">1000</span>
<span class="py">fallbackfee</span><span class="p">=</span><span class="mf">0.0002</span>
</code></pre></div></div>

<p>Get coins https://faucet.ctvsignet.com/ / DM me</p>

<ol>
  <li>
    <p>Follow the install instructions on
https://learn.sapio-lang.org/ch01-01-installation.html You can skip the the
sapio-studio part / pod part and just do the Local Quickstart up until
“Instantiate a contract from the plugin”. You’ll also want to run cargo
build –release from the root directory to build the sapio-cli.</p>
  </li>
  <li>Open up the site https://rjsf-team.github.io/react-jsonschema-form/</li>
  <li>Run sapio-cli contract api –file
plugin-example/target/wasm32-unknown-unknown/debug/sapio_wasm_plugin_example.wasm</li>
  <li>Copy the resulting JSON into the RJSF site</li>
  <li>Fill out the form as you wish. You should see a JSON like
    <div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
  </span><span class="nl">"context"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
 </span><span class="nl">"amount"</span><span class="p">:</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w">
 </span><span class="nl">"network"</span><span class="p">:</span><span class="w"> </span><span class="s2">"Signet"</span><span class="p">,</span><span class="w">
 </span><span class="nl">"effects"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
   </span><span class="nl">"effects"</span><span class="p">:</span><span class="w"> </span><span class="p">{}</span><span class="w">
 </span><span class="p">}</span><span class="w">
  </span><span class="p">},</span><span class="w">
  </span><span class="nl">"arguments"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
 </span><span class="nl">"TreePay"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
   </span><span class="nl">"fee_sats_per_tx"</span><span class="p">:</span><span class="w"> </span><span class="mi">1000</span><span class="p">,</span><span class="w">
   </span><span class="nl">"participants"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="w">
     </span><span class="p">{</span><span class="w">
       </span><span class="nl">"address"</span><span class="p">:</span><span class="w"> </span><span class="s2">"tb1pwqchwp3zur2ewuqsvg0mcl34pmcyxzqn9x8vn0p5a4hzckmujqpqp2dlma"</span><span class="p">,</span><span class="w">
       </span><span class="nl">"amount"</span><span class="p">:</span><span class="w"> </span><span class="mi">1</span><span class="w">
     </span><span class="p">},</span><span class="w">
     </span><span class="p">{</span><span class="w">
       </span><span class="nl">"address"</span><span class="p">:</span><span class="w"> </span><span class="s2">"tb1pwqchwp3zur2ewuqsvg0mcl34pmcyxzqn9x8vn0p5a4hzckmujqpqp2dlma"</span><span class="p">,</span><span class="w">
       </span><span class="nl">"amount"</span><span class="p">:</span><span class="w"> </span><span class="mi">1</span><span class="w">
     </span><span class="p">}</span><span class="w">
   </span><span class="p">],</span><span class="w">
   </span><span class="nl">"radix"</span><span class="p">:</span><span class="w"> </span><span class="mi">2</span><span class="w">
 </span><span class="p">}</span><span class="w">
  </span><span class="p">}</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div>    </div>
    <p>You may have to delete some extra fields (that site is a little buggy).</p>
  </li>
</ol>

<p>Optionally, just modify the JSON above directly.</p>

<ol>
  <li>Copy the JSON and paste it into a file ARGS.json</li>
  <li>Find your sapio-cli config file (mine is at
~/.config/sapio-cli/config.json). Modify it to look like (enter your rpcauth
credentials):
    <div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
  </span><span class="nl">"main"</span><span class="p">:</span><span class="w"> </span><span class="kc">null</span><span class="p">,</span><span class="w">
  </span><span class="nl">"testnet"</span><span class="p">:</span><span class="w"> </span><span class="kc">null</span><span class="p">,</span><span class="w">
  </span><span class="nl">"signet"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
 </span><span class="nl">"active"</span><span class="p">:</span><span class="w"> </span><span class="kc">true</span><span class="p">,</span><span class="w">
 </span><span class="nl">"api_node"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
   </span><span class="nl">"url"</span><span class="p">:</span><span class="w"> </span><span class="s2">"http://0.0.0.0:18332"</span><span class="p">,</span><span class="w">
   </span><span class="nl">"auth"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
     </span><span class="nl">"UserPass"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="w">
       </span><span class="s2">"YOUR RPC NAME"</span><span class="p">,</span><span class="w">
       </span><span class="s2">"YOUR PASSWORD HERE"</span><span class="w">
     </span><span class="p">]</span><span class="w">
   </span><span class="p">}</span><span class="w">
 </span><span class="p">},</span><span class="w">
 </span><span class="nl">"emulator_nodes"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
   </span><span class="nl">"enabled"</span><span class="p">:</span><span class="w"> </span><span class="kc">false</span><span class="p">,</span><span class="w">
   </span><span class="nl">"emulators"</span><span class="p">:</span><span class="w"> </span><span class="p">[],</span><span class="w">
   </span><span class="nl">"threshold"</span><span class="p">:</span><span class="w"> </span><span class="mi">1</span><span class="w">
 </span><span class="p">},</span><span class="w">
 </span><span class="nl">"plugin_map"</span><span class="p">:</span><span class="w"> </span><span class="p">{}</span><span class="w">
  </span><span class="p">},</span><span class="w">
  </span><span class="nl">"regtest"</span><span class="p">:</span><span class="w"> </span><span class="kc">null</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div>    </div>
  </li>
  <li>Create a contract template:
    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cat </span>ARGS.json| ./target/release/sapio-cli contract create  <span class="nt">--file</span> plugin-example/target/wasm32-unknown-unknown/debug/sapio_wasm_plugin_example.wasm  | jq <span class="o">&gt;</span> UNBOUND.json
</code></pre></div>    </div>
  </li>
  <li>Get a proposed funding &amp; binding of the template to that utxo:</li>
</ol>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cat </span>UNBOUND.json| ./target/release/sapio-cli contract <span class="nb">bind</span> | jq <span class="o">&gt;</span> BOUND.json
</code></pre></div></div>
<ol>
  <li>Finalize the funding tx:</li>
</ol>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cat </span>BOUND.json | jq <span class="s2">".program[</span><span class="se">\"</span><span class="s2">funding</span><span class="se">\"</span><span class="s2">].txs[0].linked_psbt.psbt"</span> | xargs <span class="nb">echo</span> | xargs <span class="nt">-I</span>% ./bitcoin-cli <span class="nt">-signet</span> utxoupdatepsbt % |  xargs <span class="nt">-I</span>% ./bitcoin-cli <span class="nt">-signet</span> walletprocesspsbt % | jq <span class="s2">".psbt"</span> | xargs <span class="nt">-I</span>% ./bitcoin-cli <span class="nt">-signet</span> finalizepsbt % | jq <span class="s2">".hex"</span>
</code></pre></div></div>

<ol>
  <li>Review the hex transaction/make sure you want this contract… and then
send to network:
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>./bitcoin-cli -signet sendrawtransaction 020000000001015e69106b2eb00d668d945101ed3c0102cf35aba738ee6520fc2603bd60a872ea0000000000feffffff02e8c5eb0b000000002200203d00d88fd664cbfaf8a1296d3f717625595d2980976bbf4feeb
10ab090180ccdcb3faefd020000002251208f7e5e50ce7f65debe036a90641a7e4d719d65d621426fd6589e5ec1c5969e200140a348a8711cb389bdb3cc0b1050961e588bb42cb5eb429dd0a415b7b9c712748fa4d5d
fe2bb9c4dc48b31a7e3d1a66d9104bbb5936698f8ef8a92ac27a650663500000000
</code></pre></div>    </div>
  </li>
  <li>Send the other transactions:</li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cat BOUND.json| jq .program | jq ".[].txs[0].linked_psbt.psbt" | xargs -I% ./target/release/sapio-cli psbt finalize --psbt %  | xargs -I% ./bitcoin-cli -signet sendrawtransaction %
</code></pre></div></div>

<p>Now what?</p>

<ul>
  <li>Maybe load up the Sapio Studio and try it through the GUI?</li>
  <li>Modify the congestion control tree code and recompile it?</li>
  <li>How big of a tree can you make (I did about 6000 last night)?</li>
  <li>Try out other contracts?</li>
</ul>

  </div>
<hr>
  
<hr>
  <div class="post">
    <h2 class="post-title">
        <a href="/bitcoin/2021/12/24/advent-27/">
        RoadMap or Load o' Crap?
      </a>
  </h2>
  <h4>Day 27: Rubin's Bitcoin Advent Calendar</h4>


    <span class="post-date">24 Dec 2021</span>

    <p><em>Welcome to day 27 of my Bitcoin Advent Calendar. You can see an index of all
the posts <a href="/advent21">here</a> or subscribe at
<a href="https://judica.org/join">judica.org/join</a> to get new posts in your inbox</em></p>

<p>I know, I know.</p>

<p>God forbid, a roadmap. People hate roadmaps. As I’ve noted
<a href="/blog/2021/07/02/covenants/">before</a>:</p>

<blockquote>
  <p><strong>Bitcoin Eschews Roadmaps and Agendas.</strong>
I provide this maxim to make clear that this document is by no means an official
roadmap, narrative, or prioritization. However, it is my own assessment of what
the current most pragmatic approach to upgrading Bitcoin is, based on my
understanding of the state of outstanding proposals and their interactions.</p>

  <p>My priorities in producing this are to open a discussion on potential new
features, risk minimization, and pragmatic design for Bitcoin.</p>
</blockquote>

<p>If you didn’t click, I definitely recommend reading <a href="/blog/2021/07/02/covenants/">the quoted
post</a> in conjunction with this one. As well as, if
you’re a first time visitor to the Advent Calendar, the preceding 26 posts.</p>

<hr />

<p>In contrast to my prior post, this roadmap is going to be less about full
justifications and unbiased weightings and tallyings of sentiments and more just
me spitting out a timeline we could introduce changes on. It’s not a final
answer, and in no way authoritative, but it’s a launch point for a discussion
that has to happen in some way at some point in order to advance a soft-fork.</p>

<p><em>Consider this as being posted for the sake of public review. If you disagree
with this, let me know why! But please no attacks just for the act of discussing
the topic of soft-fork activation<sup id="fnref:ordo" role="doc-noteref"><a href="#fn:ordo" class="footnote" rel="footnote">1</a></sup>.</em></p>

<p>So buckle up here’s how we could make Bitcoin kick ass in 2022 and beyond:</p>

<h1 id="2022-the-year-of-the-covenant">2022: The Year of the Covenant</h1>

<h2 id="bip-119-timeline">BIP-119 Timeline</h2>
<p>CheckTemplateVerify is getting close to ready to go. There are numerous
<a href="https://utxos.org/signals">supporters (listed on utxos.org)</a>, few detractors,
and a bumper crop of amazing use cases (did you read the calendar?) waiting for
us on the other side of CTV activation. The major critiques are that we might want
something that does ‘more’ than CTV itself, or to include it in a bundle of
things.</p>

<p>My take: we’re not Gordon Gecko. Greed is <em>Not</em> Good. CTV represents a clean, well
contained, unproblematic upgrade that’s going to deliver hella functionality in
service of scaling, decentralization, self custody, and privacy. Let’s secure
the bag for Bitcoin users everywhere and make it happen. We can always do more,
later, informed by what extensions we need for rapidly maturing tools like
Sapio. CTV is also technically specified and implemented sufficiently – a view
I’ve confirmed with a couple other devs – that it is able to be considered for
release.</p>

<h3 id="what-would-have-to-happen-to-release-ctv">What would have to happen to release CTV?</h3>

<ol>
  <li>More signalers would need to be on
<a href="https://utxos.org/signals">utxos.org/signals</a> or other platforms to demonstrate
interest and demand for CTV, ideally explaining which use cases are important to
them and why. Every voice counts for consensus. There is no list long enough to
capture what it would mean to have consensus, so there is not some threshold
that implies a ‘go ahead’, but N+1 is clearly better than N.</li>
  <li>More “regular contributors” would need to spend time reviewing the code and BIP to
assure themselves of correctness and safety.  Nothing can move forward with out,
no matter the count of casual contributors. Many regular contributors don’t want
to ‘get political’ and look at forks. Fortunately, while all consensus changes
are complex, CTV is a very tiny and easy to review change in comparison with
SegWit or Taproot (more similar to CheckLockTimeVerify – a couple hundred lines
of consensus code, a couple hundred lines of non consenus code, and a couple
thousand lines of tests, no cryptographic primitives). <strong>NOTE:</strong> This is a big
if!  Every contributor has the right to review, and ACK or provide a reasoned
NACK.  Even if everyone else is excited about something doesn’t mean there isn’t
space for new thought-through dissent. At the end of the article, I discuss
some concrete next steps to ensure more developer review occurs.</li>
  <li>We would need to merge the implementation. This is simple, but enough ACKs have to
come in and rebases on other subsequent changes to get it in. This can
happen ahead of ‘full consensus’ since there are no deployment parameters,
but aids in increasing the testing priority of CTV.</li>
  <li>We would need to get a majority of miners/pools primed to accept the upgrade.</li>
  <li>Major alternative implementation maintainers (e.g., BTCD, Knots) should show
willingness to implement or accept patches for the new rules (although it’s a
soft-fork, this is good to do).</li>
  <li>We would need to decide on release parameters for the implementation.</li>
  <li>We would need to merge and release a client with release parameters</li>
  <li>The client would needs to lock-in by a supermajority of miners signalling.</li>
  <li>Then, and only then, would CTV be fully available.</li>
</ol>

<h3 id="whats-the-maximally-aggressiveoptimistic-timeline">What’s the Maximally Aggressive/Optimistic Timeline?</h3>

<ol>
  <li>Soft Signals / Developer Review: 2-3 months required to get ACKs on the
implementation, assuming no major changes required.</li>
  <li>Merge: Instant, just whenever there are ACKs against the implementation being
safe and matching BIP. Usually, enough ACKs for a PR is 2 regular contributors,
the comitter, and a maintainer, but for consensus changes there is no threshold
at which Bitcoin considers a change sufficiently peer reviewed. A consensus
change should see higher quality reviews, as well as external consensus that the
change is desired.</li>
  <li>Getting miners primed to signal: ~20% of pools are on
<a href="https://utxos.org/signals">utxos.org/signals</a>, more should be coming on board
soon. Don’t expect this to take additional time if in conjunction with Developer
review.</li>
  <li>Debating Timelines: ~1 month to agree on a release timeline</li>
  <li>Preparing a release: ~1 month to do release candidates and testing.</li>
  <li>Speedy Trial: 3 months of signalling, 3 months of waiting for lock-in to active.</li>
</ol>

<h3 id="overall-it-could-look-like-this">Overall, it could look like this:</h3>

<p>On March 15th developers reach agreement on merging BIP-119’s implementation.
On April 15th, agreement is reached on release parameters for signalling from ~
June 1st to ~September 1st. The activation height would be November 10th.  A client
is prepared, and tested, and released. No issues are found. The miners signal at
some point in the 3 month window above the threshold. CTV locks-in. Developers
can prep wallet software for deeper integration. CTV activates before
Thanksgiving, avoiding the “dire straits” of
thanksgiving-hanukkah-christmas-chinese-new-year-valentines-day season.</p>

<p><em>but that’s basically identical to Taproot’s timeline?</em></p>

<p>Exactly. If we act on this timeline starting in early January 2022, it is
possible to meet an almost identical timeline for CTV as Taproot.</p>

<p>Part of why it works is that the next major release is scheduled for 2022-04-01.
Soft forks are usually released as a minor patch on top of a few recent major
releases. So CTV could be:</p>

<ol>
  <li>Code included in 23.0 for CTV, no activation parameters</li>
  <li>Activation parameters in 23.1, and backported to 22.x, 21.x, and (really this is up to maintainers how far to backport!).</li>
  <li>23.1 released before June 1st, 2022.</li>
</ol>

<p><strong>What could go wrong?</strong></p>

<ol>
  <li><strong>Concern:</strong> There could be  a small tweak to CTV that makes it marginally
better, and it’s worth adding some extra review time as a result.<br />
<strong>Rebuttal:</strong><br />
<em>CTV is highly design specific, so it’s unlikely there could be a change needed,
but not impossible. Changes would be unlikely to be large, though, e.g. perhaps
comitting to the same fields in a different order. Taproot saw some small
changes about a month before being merged.</em></li>
  <li><strong>Concern:</strong> Release process has a delay due to an issue uncovered in non-CTV code.<br />
<strong>Rebuttal:</strong><br />
<em>Soft fork releases are usually a minor patch onto an existing version, so it’s
unlikely that there would be a new bug, but the release would still be planned
and could resume as soon as patched. Speedy Trial’s ‘delayed activation’ also
helps with providing more time for (non-consensus) bug fixes in the client
between lock-in and activation.</em></li>
  <li><strong>Concern:</strong> Release process has a delay due to an issue uncovered in CTV’s code.<br />
<strong>Rebuttal:</strong><br />
<em>If the issue is a bug, it would merit more strict scrutiny on the code and
tests (which are pretty comprehensive currently) as to how they could be passing
with an issue like that. Once patched and reviewed, it’s still possible to merge
and release. However, the issue could also be a conceptual bug (e.g., here’s how
to do recursive covenants with CTV), which would certainly delay (and I’d be the
first to say it!) continuing with CTV at the present time. The former issue is
likely more likely than the latter, and that risk is defrayed by thorough code
review and testing.</em></li>
  <li><strong>Concern:</strong> There’s not enough developer consensus conceptually.<br />
<strong>Rebuttal:</strong><br />
<em>There are many developers supporting on
<a href="https://utxos.org/signals">utxos.org/signals</a>. I’ve also made an effort to
reach out to a variety of developers who are not on the site to seek out
dissent, and I do not think there are any current safety concerns, which is
positive for developers who might not Ack but don’t have a ‘this is a grave
mistake’ Nack up their sleeves. Again, there’s no well defined threshold for
what is “enough”.</em></li>
  <li><strong>Concern:</strong> Miners don’t want CTV and don’t signal for it.<br />
<strong>Rebuttal:</strong><br />
_20% of the hash pools already say they do want it, and more should be joining
that list soon™. Should that not happen, there could be a UASF effort to ensure
the activation of BIP-119 if users want CTV strongly enough. _</li>
  <li><strong>Concern:</strong> Disagreement on Activation mechanism.<br />
<strong>Rebuttal:</strong><br />
<em>Taproot’s Speedy Trial (ST) worked very well. Big Success. No need to mess with
the recipe. UASF-clienters know how to make the mods to the activation logic for
whatever they want as a competing client. But perhaps that’s not a comfortable
status quo, so this is certainly one to watch. I’ve made my own remarks on what
order of operations I think ST/UASF/etc should go in
<a href="https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2021-April/018833.html%5C">here</a>,
but there’s not consensus on this topic. Notably, there is some dissent from
reusing ST at all. While important, activation logic is a secondary (but still
critical) concern to the decision to accept the current specification and
implementation of CTV in the first place, and discussion on that can proceed
in parallel to progress on consensus on the implementation.</em></li>
</ol>

<h2 id="and-then-what">And Then What?</h2>

<p>After the release of CTV Soft Fork Client, what goes next?</p>

<ol>
  <li>Jeremy takes a vacation for a month.</li>
  <li>Sapio continues to improve dramatically, as detailed in the last post.</li>
  <li>Work begins on new Opcodes.</li>
  <li>More fun applications get built on CTV/Sapio (for examples, review the entire series of
<a href="/advent21">the Advent Calendar</a>, but a few of my favorites are <a href="/bitcoin/2021/12/10/advent-13/">Payment
Pools</a>,
<a href="/bitcoin/2021/12/07/advent-10/">Vaults</a>, and <a href="/bitcoin/2021/12/17/advent-20/">Bonded
Oracles</a>).</li>
  <li>Non-Interactive Lightning Channel BOLT drops.</li>
  <li>Payment Pool spec drops with LN integration.</li>
  <li>(Privacy + Scale)++</li>
</ol>

<h2 id="new-opcodes-you-say">New Opcodes you say?</h2>

<p>Yep, new opcodes. As soon as CTV is merged, there are some new features that
could be tooled into BIPs without much controversy, given their simplicity:</p>

<ol>
  <li>New Math Opcodes</li>
  <li>OP_AMOUNT</li>
  <li>OP_CSFS</li>
</ol>

<p>These are “universally agreed on” bits of functionality that have very little
wiggle room in how they might be specified. Therefore their implementation,
testing, and release is mostly mechanical. This makes them good bets for a
concrete timeline because they’re a rote-development task with few research
dependencies and easily agreed on design.</p>

<p>With hard work, these could be reviewed and tested in time for Speedy Trial
signalling in June 2023 (+1 year), with realllllly hard work 6 months earlier
(but there are conflicting priorities for developer’s time – e.g., building
stuff with/for CTV and Taproot – that make that super unlikely).</p>

<h3 id="what-about-anyprevout">What about Anyprevout</h3>

<p>Anyprevout is 1000000% not ruled out here for advancing to the consensus stage
in 2022. There are a couple things happening on Anyprevout that make me suspect
it might be more primed towards early-mid 2024 best case.</p>

<ol>
  <li>Taproot upgraded channels taking some steam away from Eltoo with AJ’s
proposal to do state compaction via PTLCs.</li>
  <li>Disagreement over no justice transactions in the community for high value
channels.</li>
  <li>Open research on specific Eltoo protocol implementation / need for other
tools (like SIGHASH_BUNDLE).</li>
  <li>Lack of an open PR and test suite for it.</li>
  <li>CSFS + CTV permitting a version of Eltoo.</li>
</ol>

<p>All of these reasons point to it being highly unlikely APO could be finished on
the timeline presented for CTV, but also that given a desire to see a working LN
client (ensuring the protocol is sound end-to-end without modifications) leads
to additional engineering complexity.</p>

<p>I’ve heard on the rumour vine some excellent engineers might start working on an
Eltoo implementation, I believe that work to be of tremendous value to gain
consensus on deploying anyprevout.</p>

<p>Given that a couple years seems like the best case for a set of upgrades around
APO to deliver Eltoo, if we have the ability to deliver CTV now, it is a good
asymmetric bet for delivering utility to Bitcoin’s users.</p>

<p>Suppose I’m wrong, and Anyprevout really could get done in 2022. Shouldn’t it
be ‘next’ and CTV can wait?</p>

<p>The notion that any soft-fork is “next” for consideration and blocks any other
from being considered is somewhat contrary to the support for parallel
soft-forks with distinct version bits used for signalling. The possibility of
deploying soft forks on independent bits means things can be ultimately
“proposed” whenever they’re mature enough to enter the “final stage” and the
timing fits with Bitcoin’s general release schedule. The chief counterarguments
to this are twofold: One, review resources are finite and we can’t even think
about \(&gt;1\) thing at a time; Two, it’s bad if the protocol is simultaneously
deploying \(N\) upgrades and any of them might fail, leading to \(2^N\)
potential protocol states. It’s actually the other way around: if things can
proceed in parallel we can get more review, because developers won’t feel that
reviewing others work has the potential to slow down their own, and we’ll be
more certain that the upgrades we release are strongly desired by the community
(i.e., will end in a UASF if not activated due to miner apathy).</p>

<h3 id="what-about-tapleafupdateverify">What about TapLeafUpdateVerify</h3>

<p>If I had to estimate, I’d say TLUV needs another year or so of people ‘stewing’
on the possibilities and design before it could move forward. It would then
probably need at least a year of tinkering to get a well-accepted
implementation, and then a year for release process. So let’s say best case it
could be a 2024 thing, more likely 2025 given Anyprevout is seen as higher
priority for the engineering work.</p>

<h3 id="what-about-inherited-ids-iids">What about Inherited IDs (IIDs)?</h3>

<p>They didn’t make the cut in the earlier piece since they’re a bit more abstract,
but I’d posit that IIDs could also approach a 2024 timeline were the developer
of the idea to spend a heckin’ big amount of time on advocacy for the concept in
2022, and present a clean implementation of the concept (&amp; demonstration of
overheads) by 2023. This is complicated by the issue that he would have to also
solve issues with requiring a new index, such as helping assist assumeutxo
compatibility, write reindexing logic from genesis (or somehow exclude old
coins?), and also work on utreexo compatibility. Those all seem tractable,
but very hard to do for someone who is not a full-time long-time contributor
to the project, but I’m a believer that the job could be done given the quality
of the insights in the IIDs paper.</p>

<h2 id="parallel-developments">Parallel Developments?</h2>

<p>In parallel to the above, there are some things that I think are <em>very cool</em>
that should remain under development, but don’t have a clear path to inclusion
presently.</p>

<p>The first is <a href="https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-September/018168.html">Transaction Sponsorship</a>, which could substantially 
simplify many protocols on top of Bitcoin, especially things like Eltoo and CTV
stuff. We can’t predict that too well because it will depend on what developers
end up running up against with current best practices around CPFP/RBF, but
I suspect it might become popular if a small group of developers prioritizes
such an approach as a unified front. Since it’s technically simple, it wouldn’t
take much time to implement, but because there’s very little consensus for
it right now it’s not fit for inclusion in a roadmap.</p>

<p>The next is <a href="https://blog.blockstream.com/en-simplicity-github/">Simplicity</a>. Simplicity could completely change how Bitcoin
scripting works and is super duper exciting. I guess it’s going out on Elements
sometime soon? However, it’s stupidly complicated for most devs to fully
understand (although it is called simplicity…), so it would take a fair
amount of time (read: years) before the implementation could be sufficiently
independently reviewed by the intersection of qualified Bitcoin and Programming
Language theory reviewers. The interesting thing about Simplicity with respect
to this roadmap is that because it’s so general, as soon as it seems like
Simplicity would be on Bitcoin within ~1.5 years, it’s likely all other
scripting soft fork developers would “stop” development<sup id="fnref:note" role="doc-noteref"><a href="#fn:note" class="footnote" rel="footnote">2</a></sup> and focus on
deployment as Simplicity Jets.</p>

<hr />

<h1 id="concrete-next-steps">Concrete Next Steps</h1>
<p>Should this plan not seem feasible to the near unanimity of the community for us
the deliver on (e.g., with +2-3 months of the suggested timeline), I don’t think
there is another good opportunity to enact on an activation of CTV and the best
course of action would be to delay +1 year. There could be a UASF for it, since
there is strong user demand for CTV, but I wouldn’t personally lead the charge
on that beyond ensuring that the BIP-119 code remains up-to-date and is
implemented correctly.</p>

<p>Assuming someone doesn’t make a bold argument that gives me or the aggregate
current supporters of CTV pause, I plan to begin holding a fortnightly CTV
review session to iron out any details, additional testing, code review, and
activation plans. I would also like to help a third party host a <a href="https://bitcoincore.reviews">review
club</a>, although the focus of Review Club is more
educational for the reviewers as opposed to for the purpose of formally
reviewing the code for merge.</p>

<hr />

<p>You’ve now reached the end of Rubin’s Bitcoin Advent Calendar, 2021! Congrats.
<code class="language-plaintext highlighter-rouge">wc -w $(ls | grep advent)</code> tells me that means you read 50,773 words total of
me rambling on about covenants. That’s PhD thesis length! I really hope you
found something to enjoy.</p>

<p>A special thanks to all who helped review this post in particular and provided
feedback in ensuring I’ve done an OK job capturing the complexity of gaining
consensus. To the extent that I haven’t succeeded in representing your
perspectives here, I take sole responsibility for the inadequacy. Your
constructive feedback on how to improve is welcomed. A further special thanks to
Ryan Gentry who encouraged me to produce the series in the first place, and to
Sarah Satoshi for her support as I battled my way through this task.</p>

<p>As for me, I’m off to sip some Eggnog and eat some holiday cookies! I’ll take a
little bit of a break, and be back in the New Year following up on next steps
and dropping fresh content for y’all as always.</p>

<p>Merry Christmas and Happy New Years,</p>

<p>Jeremy</p>
<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:ordo" role="doc-endnote">
      <p>You do you though. It’d really hurt my feelings if you called me a Smelly Weasel attacking Bitcoin. <a href="#fnref:ordo" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:note" role="doc-endnote">
      <p>Transaction Sponsorship cannot be done, as far as I understand, as a part of Simplicty. Things like that would progress independently. <a href="#fnref:note" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>

  </div>
<hr>
  
<hr>
  <div class="post">
    <h2 class="post-title">
        <a href="/bitcoin/2021/12/23/advent-26/">
        The History and Future of Sapio
      </a>
  </h2>
  <h4>Day 26: Rubin's Bitcoin Advent Calendar</h4>


    <span class="post-date">23 Dec 2021</span>

    <p><em>Welcome to day 26 of my Bitcoin Advent Calendar. You can see an index of all
the posts <a href="/advent21">here</a> or subscribe at
<a href="https://judica.org/join">judica.org/join</a> to get new posts in your inbox</em></p>

<p>Sapio began as little more than a slide in presentations I would give on what
BIP-119 could be with the support of a programming environment.</p>

<p>While my conceptions of what could be built with CTV were about on-par with
where they are today, the tools available were very clunky. You can see
one of the original diagrams from the C++ Code below (<a href="https://github.com/JeremyRubin/bitcoin/blob/8f297449ff296533d7dd0ac44b62cb3cc33d1b83/src/wallet/rpcwallet.cpp#L1339">code here</a>).</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/*
    *                   [      vault_to_vault n  ]
    *                     |a                   |b
    *                    (0)                  (1)
    *                    /\                   /\
    * wait + maturity   /  \                 /  \ wait + step_period    (attached)
    * [   hot_to_hot   ]   /  [vault_to_cold]    [vault_to_vault n - 1]
    *                     /                         |           |
    *        [hot_to_cold]                         (0)         (1)
    *                                               .           .
    *                                               .           .
    *                                                           .
    *                                                     wait + step_period * n   (attached)
    *                                                   [vault_to_vault 0]
    *                                                      |
    *                                                     (0)
    *                                                     */</span>
</code></pre></div></div>

<style>
code {
    font-size: 0.75em !important;
}
</style>

<p>When I presented it on February 1st, 2020 at the CTV workshop, one of the last
Bitcoin events before the pandemic began<sup id="fnref:mit" role="doc-noteref"><a href="#fn:mit" class="footnote" rel="footnote">1</a></sup>, I knew I had to present a more
concrete vision on how smart contracts could be built, rather than spit-and-glue
C++.</p>

<p>And so I included slide inspired by the hand rolled smart contracts I was making
in C++ about how the technique could be generalized.</p>

<p><img src="/public/img/bitcoin/advent/sapio-future/sapio-idea.svg" alt="" />
<em>a slide at the feb. 2020 CTV workshop.</em></p>

<blockquote>
  <p>This is a research project I am interested in pursuing. We have a few
scripting languages. We have Dan here who wrote Ivy. There’s also Balzac and
Solidity. It’s poorly named, but it actually has some really interesting ideas
that aren’t in other scripting languages for bitcoin. There’s some notion of
participants with private state they are storing, and has some notion of
interactivity. I also threw up there BlueSpec which is like a VHDL competitor
that is pretty neat. If you think about it, there’s a software layer for
controlling vaults but there’s also a hardware layer- so how can we describe
transactional hardware? You wind up with similar controls as a BlueSpec-like
language where you are creating plumbing and a description of how things are
moving rather than something that has imperative state.</p>

  <p>As an example, one of the properties with OP_CHECKTEMPLATEVERIFY that is cool is
the narrow window of a standard OP_CHECKTEMPLATEVERIFY script is that you have
this composability property where for a given model that goes to arbitrary
address outputs, you can just throw another one inside it. As the outputs of
that annuinity, you can put undo send as the outputs of that annunity, and you
can tag on more and more programs into that if you want. On this slide is a
templately description of a language, which helps if someone else given the same
program description can verify that the hash is the same for the given inputs.
Instead of sending you a million branches, you can generate them yourselves.</p>

  <p>Q: Is there code for your metascript thing?</p>

  <p>A: No. It’s just an idea I’ve been toying with. I got relatively close to
metascript just writing in C++ just writing with C++ templates. Then I got ready
to kill myself doing that because writing templates.</p>
</blockquote>

<p>I’d discussed similar slides at earlier events, usually included it as an
example of something <em>someone else</em> could build while I kept pluggin’ away
working on Bitcoin Core. Eventually I realized that me claiming that CTV could
be used to do these things and CTV demonstrably doing these things was an
obstacle… I needed to make the prototype.</p>

<p>So I set off hacking together a prototype… I spent an afternoon or two mucking
around in C++ only to realize that wasn’t going to happen, and then I switched
to python. Python was a great choice, and after quite a bit of time pluggin
away, I had something that actually worked.</p>

<p>There was a moment of magic where I connected it to the Sapio Studio (which
actually existed long before Sapio as just a visualizer for a set of
transactions) to load a contract written in python and…  it worked. Really
well. It felt incredible. I began talking more about what Sapio could do,
thinking through some of the problems and solutions. I  even gave a talk in the
metaverse with Udi where I dropped my virtual laser pointer on the ground for a
minute and couldn’t pick it back up.</p>

<p><img src="/public/img/bitcoin/advent/sapio-future/reckless.png" alt="" />
<em>there were more people sitting further back I swear…</em></p>

<p>At a certain point I decided to start working on cleaning up Sapio by using
Python’s gradual typing and trying to convert to using Miniscript instead of my
custom-made Sapio script fragment builder. I was neck deep in type refactors and
then I had a deep realization:</p>

<h2 id="python-fucking-sucks">Python FUCKING SUCKS</h2>

<p>I was incredibly greatful for the rapid iterating that python allowed me, but I
realized at this point that it was going to be nearly impossible to make Sapio
actually good and not just a toy working in python.  What had started as a proof
of concept for someone to do “for real” had gotten good enough conceptually but
was bursting at the seams and was not going to ever yield something production grade.</p>

<p>So I did a reset.</p>

<p>I started building Sapio in Rust, re-implementing (but much more cleanly) the
paradigms that I had previously developed, relying on well tested and type
rust-bitcoin libraries instead of janky test-framework python code from Bitcoin
Core.</p>

<p>And one day – almost like Deja Vu – I plugged the Sapio Rust served in place
of the Python one for the Sapio Studio and everything Just Worked™.</p>

<p>Since then, Sapio has only matured and gotten better and better with each
passing month.  I’ve added tons of new features, improved the underlying
architecture, made the ABIs more well defined, built stronger intergrations with
the GUI, and more. Today, Sapio is actually usable on mainnet (if you’re an
expert at least), and I’ve used to do congestion control payments and art
projects.</p>

<p>Sapio has helped me cut through the content for this Advent Calendar like a
swiss army knife.  It’s actually becoming a pretty decent tool!</p>

<h1 id="whats-next">What’s Next</h1>

<p>Sapio needs to get to the next level. There are many major areas of work in the
pipeline. You might think of this as “Sapio is so incomplete it’s not ready”.
I think of it more as Sapio is just getting started:</p>

<h4 id="upgrade-to-taproot">Upgrade to Taproot</h4>

<p>Support for Taproot in rust-bitcoin and rust-miniscript is coming! Once that
lands, I need to rebase (and maybe upstream?) some Sapio features, and then
update the compiler to always use Taproot outputs!</p>

<h4 id="improve-sapio-ctv-emulators-with-taproot-if-ctv-seems-to-be-slow">Improve Sapio CTV Emulators with Taproot (if ctv seems to be slow)</h4>

<p>Once taproot lands, the multi-sig federated oracle designs can be set up to do a
MuSig Schnorr signature instead of just a bare multi-sig, allowing wider federations.</p>

<p>This engineering work only really matters if CTV seems unlikely, but could
be useful to have anyways for future purposes &amp; extensions to Sapio.</p>

<h4 id="build-out-some-full-featured-applications-backed-by-sapio">Build out some “full featured” applications backed by Sapio</h4>

<p>Right now Sapio works for making little Applets, but there is no “end to end”
software (e.g., vaults) made in Sapio.</p>

<p>This requires work on both the Sapio Studio front and potentially on a website
for things like Sapio NFTs.</p>

<p>This will push the boundaries on integrating Sapio into real applications.</p>

<p>One particular feature that would be great is ‘auto-signing’ on valid state
transitions proposed at a certain continuation point. For example, if we have an
NFT we want to dutch auction, we should be able to have a sapio module running
that is happy to spit out the relevant transactions with a nice API.</p>

<h4 id="more-advanced-programming-of-transactions">More advanced programming of transactions</h4>

<p>Currently the Sapio transaction builder from within Sapio branches is a bit
limited in what it can express.</p>

<p>Augmenting it with the ability to more fully describe partially signed bitcoin
transactions (PSBTs), e.g., when used in the <code class="language-plaintext highlighter-rouge">continuation</code> context would
advance the state of the art.</p>

<h5 id="key-management">Key Management</h5>
<p>Relatedly, it would be really useful if you could tell Sapio how to access a
signing module and have sapio use that external key to generate the appropriate
signatures for the state transitions.</p>

<h4 id="better-sapio-cli--server-that-can-keep-wasm-modules-loaded-in-memory-aiding-performance">Better sapio-cli / server that can keep WASM modules loaded in memory, aiding performance</h4>

<p>Right now every time a module is used the entire thing has to reload which is
super slow.</p>

<p>It should be possible to have a single server instances that manages a cache of
all modules, greatly boosting performance, especially for recursive cross-module
calling contracts.</p>
<h4 id="client-side-verification-caching-across-module-boundaries">Client Side Verification Caching Across Module Boundaries</h4>

<p>For things like NFTs that we saw, we have to always re-compile the <em>entire</em>
history of the NFT to do state transitions. However, many of these state
transitions are just doing the exact same thing every time, re-verifying from
genesis. We should be able to cache the compilations at well defined boundaries.</p>

<h4 id="better-formal-analysis-tools--type-system-on-top-of-sapio">Better formal analysis tools / type system on top of Sapio</h4>
<p>Currently Sapio has the ability to define various interfaces for composing Sapio contracts cleanly.</p>

<p>But we don’t have a great way of proving what we want a contract to do v.s. what it does.</p>

<p>This work will start as being able to express more properties about a module in
it’s “manifest”, and will culminate in being able to check the validity of compositions
of contracts based on them.</p>

<p>If anyones looking to do a PhD thesis on Sapio, this is prolly it.</p>

<h4 id="more-module-types">More Module Types</h4>

<p>Right now all WASM modules are for generating a ‘Compiled’ contract from a JSON.</p>

<p>I would love to add defined module types to cover all the standard components like:</p>

<ul>
  <li>Miniscript Fragments</li>
  <li>Then Functions</li>
  <li>Continuation Functions</li>
  <li>Transaction Template Generators</li>
  <li>Trait Verifiers</li>
</ul>

<p>and more.</p>

<h4 id="more-emulator-types">More Emulator Types</h4>

<p>Sapio works <em>today</em> with CTV <code class="language-plaintext highlighter-rouge">then</code> functions because the functionality can be
emulated by a federation of signers.</p>

<p>Figuring out how to cleanly extend the signing server paradigm to a number of
different types of Covenant proposal (e.g. APO, TLUV, CAT) or other opcodes
could add a lot of value for making Sapio the defacto platform and proving
ground for upgrades to Bitcoin.</p>

<h4 id="unifying-then-and-continuation">Unifying Then and Continuation</h4>

<p>Then and Continuation really are the same thing conceptually, it would be</p>

<h4 id="standard-library-of-useful-applications--plugins">Standard Library of useful applications / Plugins</h4>

<p>Title says it all. There should be more off the shelf things to use!</p>

<h4 id="wallet-stack-for-sapio-contracts">Wallet Stack for Sapio Contracts</h4>

<p>The Sapio Studio is rapidly imporving as a system for engaging with Sapio
contracts, but it’s lacking in the management and storage of all of a user’s
contracts. We can, and will, do a better job with this.</p>

<p>This includes being able to make watchtower-like functionality for Sapio. It’s
coming, but will likely require a lot of new features to the language spec to
express if this then that monitoring conditions. And with features comes
complexity.</p>

<p>You can see hints to this in the slide earlier, being able to react to e.g.
confirmation or mempool events.</p>

<p>This also includes dramatic improvements needed to the GUI so that users
can understand much more deeply what contracts are doing.</p>

<h4 id="binary-releases">Binary Releases</h4>

<p>Right now Sapio is just DIY to build and run it yourself, but we really ought to
work towards stable binary releases to quickstart users.</p>

<h4 id="visual-programming-for-building-sapio-contracts">Visual Programming for Building Sapio Contracts</h4>

<p>When composing together Sapio modules, I would <em>really</em> like for it to be kind
 of labview like interface for adding data or other modules, where you can
 “typecheck” that the wires (module names) are composing into slots they work.
 If that sounded like gibberish, I just mean that I want to be able to plug in a
 module hash for a NFT Sale contract into my NFT contract and have the UX give
 me real time feedback if I should be able to do that.</p>

<h4 id="sapio-package-manager--deterministic-builds--signers">Sapio Package Manager / Deterministic Builds / Signers</h4>

<p>As more modules become commonly used (e.g., like NFTs) we want to ensure all
 users can build an exact copy themselves (Deterministic Builds) or that they
 can find a build signed by a number of respected code signers (Signers). While
 we can use Cargo / crates.io for the package management of our actual rust code,
 we need something to distribute the sapio wasm blobs nicely!</p>

<h4 id="testing">Testing</h4>

<p>Writing tests for Sapio contracts is hard as heck. We need some bold ideas on
 what sorts of properties would be useful to test for. Fortunately, a lot of
 properties we care about (like not wasting money) can be checked by the sapio
 library to be safe, but we still want to be able to ensure we never lose a
 users funds out of Sapio.</p>

<p>#### Getting CTV Locked in</p>

<p>Duh!</p>

<hr />

<p>If I get even a tenth of this completed 2022 will be a good year for Sapio.</p>

<p>But I plan to get it all done.</p>

<p>Perhaps with your support – if you’re an engineer or funder interested
 in helping propel this, please reach out!</p>

<p>p.s. safe holiday travels!</p>
<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:mit" role="doc-endnote">
      <p>That honor I think goes to the MIT Bitcoin Expo. <a href="#fnref:mit" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>

  </div>
<hr>
  
<hr>
  <div class="post">
    <h2 class="post-title">
        <a href="/bitcoin/2021/12/22/advent-25/">
        Decentralized Autonomous Organizations (DAOs) Will Save Bitcoin
      </a>
  </h2>
  <h4>Day 25: Rubin's Bitcoin Advent Calendar</h4>


    <span class="post-date">22 Dec 2021</span>

    <p><em>Welcome to day 25 of my Bitcoin Advent Calendar. You can see an index of all
the posts <a href="/advent21">here</a> or subscribe at
<a href="https://judica.org/join">judica.org/join</a> to get new posts in your inbox</em></p>

<p>The title of this article is a joke. Gotcha!</p>

<p><img src="/public/img/bitcoin/advent/dao/bart.png" alt="Bart Simpson writing &quot;DAOs are just fancy multisigs&quot;." /></p>

<p>Decentralized Autonomous Organization is pretty much what’s called an <em><a href="http://itre.cis.upenn.edu/~myl/languagelog/archives/003555.html">orphan
initialism</a></em>.
So while DAO doesn’t really mean anything is decentralized, autonomous, or an
organization, but the term DAO has stuck around anyways. Even moreso than NFT!
More or less, DAOs are just fancy multisigs. But they’ve been used for all sorts
of things, ranging from attempting to buy the US Constitution as a group,
investing in startups, buying Ross Ulbricht’s NFTs, or maybe even buying my
undies.</p>

<p><img src="/public/img/bitcoin/advent/dao/nytimes.jpeg" alt="yes this is a joke" /></p>

<p>This post has some required reading. You have to have read through at least up
to <a href="/bitcoin/2021/12/10/advent-13/">payment pools</a> in the advent calendar, but
ideally you’d have read all the posts…</p>

<p>So how will fancy-multisigs save Bitcoin? In this post we’ll work through an
example of building a DAO to fund Bitcoin Core Developers, like a Bitcoin native
Gitcoin competitor.</p>
<hr />

<h1 id="what-do-we-want-from-our-dao">What do we want from our DAO:</h1>

<p>The DAO will serve three functions:</p>

<ol>
  <li>To Add members who pay in</li>
  <li>To make Payments if a Majority of the payers by value vote</li>
  <li>To mint commemorative NFTs</li>
</ol>

<h2 id="majority-rules">Majority rules</h2>

<p>DAOs are little democracies, and as such we need a voting scheme to do rule
changes whereby a threshold (e.g., 51%) decides what happens next. We have two
options, we can either count individuals as equal, or we can weight by amount of
funds contributed. We can do any threshold we like, it’s just “this many people
could steal the whole pot”.</p>

<p>For this post, we’ll do the weighted by funds contributed because that feels
closer to what’s happening in Ethereum land. Unfortunately a couple components
around generated arbitrary weighted signatures<sup id="fnref:frost" role="doc-noteref"><a href="#fn:frost" class="footnote" rel="footnote">1</a></sup> just “aren’t quite there” or have
messy tradeoffs so we won’t consider those – yet. Instead we’ll just make a silly
limit: we will allow at most 24 participants<sup id="fnref:combo" role="doc-noteref"><a href="#fn:combo" class="footnote" rel="footnote">2</a></sup>.</p>

<h2 id="implementing-a-dao">Implementing a DAO</h2>

<p>First let’s define the basics. A DAO should have Members who each are ID’d by a
key and have an amount of votes.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">#[derive(Deserialize,</span> <span class="nd">JsonSchema,</span> <span class="nd">Serialize,</span> <span class="nd">Clone)]</span>
<span class="k">struct</span> <span class="n">Member</span> <span class="p">{</span>
    <span class="n">relative_votes</span><span class="p">:</span> <span class="nb">u64</span><span class="p">,</span>
<span class="p">}</span>

<span class="nd">#[derive(Deserialize,</span> <span class="nd">JsonSchema,</span> <span class="nd">Clone)]</span>
<span class="k">struct</span> <span class="n">Dao</span> <span class="p">{</span>
    <span class="c">/// # Pool Members</span>
    <span class="c">/// map of all initial balances as PK to BTC</span>
    <span class="n">members</span><span class="p">:</span> <span class="n">BTreeMap</span><span class="o">&lt;</span><span class="n">PublicKey</span><span class="p">,</span> <span class="n">Member</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="c">/// The current sequence number (for authenticating state updates)</span>
    <span class="n">sequence</span><span class="p">:</span> <span class="nb">u64</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">Contract</span> <span class="k">for</span> <span class="n">Dao</span> <span class="p">{</span>
    <span class="nd">declare!</span> <span class="p">{</span><span class="n">updatable</span><span class="o">&lt;</span><span class="n">Proposal</span><span class="o">&gt;</span><span class="p">,</span> <span class="nn">Self</span><span class="p">::</span><span class="n">hold_vote</span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Members can hold a vote on a proposal of some kind. Let’s do proposals
that can make payments, mint NFTs, or add some noobs:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">/// New Update message for generating a transaction from.</span>
<span class="nd">#[derive(Deserialize,</span> <span class="nd">JsonSchema,</span> <span class="nd">Serialize)]</span>
<span class="k">enum</span> <span class="n">Proposal</span> <span class="p">{</span>
    <span class="c">/// # Payments</span>
    <span class="c">/// A mapping of public key in members to signed list of payouts with a fee rate.</span>
    <span class="n">Payments</span> <span class="p">{</span>
        <span class="n">payments</span><span class="p">:</span> <span class="n">BTreeMap</span><span class="o">&lt;</span><span class="n">PublicKey</span><span class="p">,</span> <span class="n">AmountU64</span><span class="o">&gt;</span><span class="p">,</span>
        <span class="c">// Some purpose for this proposal, as a String.</span>
        <span class="n">reason</span><span class="p">:</span> <span class="nb">String</span><span class="p">,</span>
    <span class="p">},</span>
    <span class="c">/// # Mint</span>
    <span class="c">/// Make some NFTs</span>
    <span class="n">Mint</span> <span class="p">{</span>
        <span class="n">minting_module</span><span class="p">:</span> <span class="n">SapioHostAPI</span><span class="o">&lt;</span><span class="n">Mint_NFT_Trait_Version_0_1_0</span><span class="o">&gt;</span><span class="p">,</span>
        <span class="n">mint_data</span><span class="p">:</span> <span class="n">Mint_NFT_Trait_Version_0_1_0</span><span class="p">,</span>
    <span class="p">},</span>
    <span class="c">/// # Add People</span>
    <span class="nb">Add</span> <span class="p">{</span>
        <span class="n">noobs</span><span class="p">:</span> <span class="n">BTreeMap</span><span class="o">&lt;</span><span class="n">PublicKey</span><span class="p">,</span> <span class="n">Member</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="p">},</span>
    <span class="nb">None</span><span class="p">,</span>
<span class="p">}</span>
<span class="c">/// required...</span>
<span class="k">impl</span> <span class="n">Default</span> <span class="k">for</span> <span class="n">Proposal</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">default</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="n">Self</span> <span class="p">{</span>
        <span class="nn">Proposal</span><span class="p">::</span><span class="nb">None</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="k">impl</span> <span class="n">StatefulArgumentsTrait</span> <span class="k">for</span> <span class="n">Proposal</span> <span class="p">{}</span>

<span class="c">/// helper for rust type system issue</span>
<span class="k">fn</span> <span class="nf">default_coerce</span><span class="p">(</span><span class="n">k</span><span class="p">:</span> <span class="o">&lt;</span><span class="n">Dao</span> <span class="k">as</span> <span class="n">Contract</span><span class="o">&gt;</span><span class="p">::</span><span class="n">StatefulArguments</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Result</span><span class="o">&lt;</span><span class="n">Proposal</span><span class="p">,</span> <span class="n">CompilationError</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="nf">Ok</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
<span class="p">}</span>

</code></pre></div></div>

<p>Now we can implement the main logic of the DAO. We want it to compute keys for
the majority to rule, and we want it to allow a majority to vote on a Proposal.
Note how when we make a payment, unlike in the Payment Pool, we decrease all
member’s proportional ownership in the pool<sup id="fnref:rat" role="doc-noteref"><a href="#fn:rat" class="footnote" rel="footnote">3</a></sup>, so that new owners are not
disadvantaged. But we could change that, to time-weight how long members have
been part of the DAO as well, or give people ‘special voting weight’
disconnected from money added. It’s really up to whatever you want…</p>

<p>We’ll implement the logic for each type of proposal (minting, adding, or paying).</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span> <span class="n">Dao</span> <span class="p">{</span>
    <span class="c">/// Sum Up all the balances</span>
    <span class="k">fn</span> <span class="nf">total</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Amount</span> <span class="p">{</span>
        <span class="nn">Amount</span><span class="p">::</span><span class="nf">from_sat</span><span class="p">(</span><span class="k">self</span><span class="py">.members</span><span class="nf">.iter</span><span class="p">()</span><span class="nf">.map</span><span class="p">(|</span><span class="n">e</span><span class="p">|</span> <span class="n">e</span><span class="na">.1</span><span class="py">.relative_votes</span><span class="p">)</span><span class="py">.sum</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">u64</span><span class="o">&gt;</span><span class="p">())</span>
    <span class="p">}</span>
    <span class="c">/// all signed the transaction!</span>
    <span class="nd">#[guard]</span>
    <span class="k">fn</span> <span class="nf">majority_rules</span><span class="p">(</span><span class="k">self</span><span class="p">,</span> <span class="mi">_</span><span class="n">ctx</span><span class="p">:</span> <span class="n">Context</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">ppl</span> <span class="o">=</span> <span class="k">self</span>
            <span class="py">.members</span>
            <span class="nf">.iter</span><span class="p">()</span>
            <span class="nf">.map</span><span class="p">(|(</span><span class="n">m</span><span class="p">,</span> <span class="n">d</span><span class="p">)|</span> <span class="p">(</span><span class="n">m</span><span class="nf">.clone</span><span class="p">(),</span> <span class="n">d</span><span class="py">.relative_votes</span><span class="p">))</span>
            <span class="nf">.collect</span><span class="p">();</span>
        <span class="c">// TODO: we should probably make guards return Result...</span>
        <span class="nf">key_groups_to_clause</span><span class="p">(</span>
            <span class="o">&amp;</span><span class="nf">compute_key_groups</span><span class="p">(</span><span class="k">self</span><span class="nf">.total</span><span class="p">()</span><span class="nf">.as_sat</span><span class="p">()</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="n">ppl</span><span class="p">)</span><span class="nf">.expect</span><span class="p">(</span><span class="s">"Well Formed"</span><span class="p">),</span>
        <span class="p">)</span>
    <span class="p">}</span>
    <span class="c">/// This Function will create a proposed transaction that is safe to sign</span>
    <span class="c">/// given a list of data from participants.</span>
    <span class="nd">#[continuation(</span>
        <span class="nd">web_api,</span>
        <span class="nd">guarded_by</span> <span class="nd">=</span> <span class="s">"[Self::majority_rules]"</span><span class="nd">,</span>
        <span class="nd">coerce_args</span> <span class="nd">=</span> <span class="s">"default_coerce"</span>
    <span class="nd">)]</span>
    <span class="k">fn</span> <span class="nf">hold_vote</span><span class="p">(</span><span class="k">self</span><span class="p">,</span> <span class="n">ctx</span><span class="p">:</span> <span class="n">Context</span><span class="p">,</span> <span class="n">update</span><span class="p">:</span> <span class="n">Proposal</span><span class="p">)</span> <span class="p">{</span>
        <span class="c">// don't allow empty updates.</span>
        <span class="k">match</span> <span class="n">update</span> <span class="p">{</span>
            <span class="nn">Proposal</span><span class="p">::</span><span class="nb">None</span> <span class="k">=&gt;</span> <span class="nf">empty</span><span class="p">(),</span>
            <span class="nn">Proposal</span><span class="p">::</span><span class="n">Mint</span> <span class="p">{</span>
                <span class="n">minting_module</span><span class="p">,</span>
                <span class="n">mint_data</span><span class="p">,</span>
            <span class="p">}</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="k">let</span> <span class="n">key</span> <span class="o">=</span> <span class="n">minting_module</span><span class="py">.key</span><span class="p">;</span>
                <span class="c">// let's now compile a new 'mint' of the NFT</span>
                <span class="k">let</span> <span class="n">new_nft_contract</span> <span class="o">=</span> <span class="nf">Ok</span><span class="p">(</span><span class="n">CreateArgs</span> <span class="p">{</span>
                    <span class="n">context</span><span class="p">:</span> <span class="n">ContextualArguments</span> <span class="p">{</span>
                        <span class="n">amount</span><span class="p">:</span> <span class="n">ctx</span><span class="nf">.funds</span><span class="p">(),</span>
                        <span class="n">network</span><span class="p">:</span> <span class="n">ctx</span><span class="py">.network</span><span class="p">,</span>
                        <span class="n">effects</span><span class="p">:</span> <span class="nn">Default</span><span class="p">::</span><span class="nf">default</span><span class="p">(),</span>
                    <span class="p">},</span>
                    <span class="n">arguments</span><span class="p">:</span> <span class="nn">mint_impl</span><span class="p">::</span><span class="nn">Versions</span><span class="p">::</span><span class="nf">Mint_NFT_Trait_Version_0_1_0</span><span class="p">(</span><span class="n">mint_data</span><span class="p">),</span>
                <span class="p">})</span>
                <span class="nf">.and_then</span><span class="p">(</span><span class="nn">serde_json</span><span class="p">::</span><span class="n">to_value</span><span class="p">)</span>
                <span class="nf">.map</span><span class="p">(|</span><span class="n">args</span><span class="p">|</span> <span class="nf">create_contract_by_key</span><span class="p">(</span><span class="o">&amp;</span><span class="n">key</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="nn">Amount</span><span class="p">::</span><span class="nf">from_sat</span><span class="p">(</span><span class="mi">0</span><span class="p">)))</span>
                <span class="nf">.map_err</span><span class="p">(|</span><span class="mi">_</span><span class="p">|</span> <span class="nn">CompilationError</span><span class="p">::</span><span class="n">TerminateCompilation</span><span class="p">)</span><span class="o">?</span>
                <span class="nf">.ok_or</span><span class="p">(</span><span class="nn">CompilationError</span><span class="p">::</span><span class="n">TerminateCompilation</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
                <span class="k">let</span> <span class="n">f</span> <span class="o">=</span> <span class="n">ctx</span><span class="nf">.funds</span><span class="p">();</span>
                <span class="n">ctx</span><span class="nf">.template</span><span class="p">()</span>
                    <span class="nf">.add_output</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="k">self</span><span class="p">,</span> <span class="nb">None</span><span class="p">)</span><span class="o">?</span>
                    <span class="nf">.add_output</span><span class="p">(</span><span class="nn">Amount</span><span class="p">::</span><span class="nf">from_sat</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">new_nft_contract</span><span class="p">,</span> <span class="nb">None</span><span class="p">)</span><span class="o">?</span>
                    <span class="nf">.into</span><span class="p">()</span>
            <span class="p">}</span>
            <span class="nn">Proposal</span><span class="p">::</span><span class="nb">Add</span> <span class="p">{</span> <span class="k">mut</span> <span class="n">noobs</span> <span class="p">}</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="k">let</span> <span class="n">adding</span> <span class="o">=</span> <span class="nn">Amount</span><span class="p">::</span><span class="nf">from_sat</span><span class="p">(</span><span class="n">noobs</span><span class="nf">.values</span><span class="p">()</span><span class="nf">.map</span><span class="p">(|</span><span class="n">m</span><span class="p">|</span> <span class="n">m</span><span class="py">.relative_votes</span><span class="p">)</span><span class="nf">.sum</span><span class="p">());</span>
                <span class="k">let</span> <span class="k">mut</span> <span class="n">new</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.clone</span><span class="p">();</span>
                <span class="n">noobs</span><span class="nf">.iter_mut</span><span class="p">()</span><span class="nf">.for_each</span><span class="p">(|(</span><span class="n">pk</span><span class="p">,</span> <span class="n">m</span><span class="p">)|</span> <span class="p">{</span>
                    <span class="n">new</span><span class="py">.members</span>
                        <span class="nf">.entry</span><span class="p">(</span><span class="o">*</span><span class="n">pk</span><span class="p">)</span>
                        <span class="nf">.and_modify</span><span class="p">(|</span><span class="n">e</span><span class="p">|</span> <span class="n">e</span><span class="py">.relative_votes</span> <span class="o">+=</span> <span class="n">m</span><span class="py">.relative_votes</span><span class="p">)</span>
                        <span class="nf">.or_insert</span><span class="p">(</span><span class="n">m</span><span class="nf">.clone</span><span class="p">());</span>
                <span class="p">});</span>
                <span class="k">let</span> <span class="n">f</span> <span class="o">=</span> <span class="n">ctx</span><span class="nf">.funds</span><span class="p">();</span>
                <span class="n">ctx</span><span class="nf">.template</span><span class="p">()</span>
                    <span class="nf">.add_sequence</span><span class="p">()</span>
                    <span class="nf">.add_amount</span><span class="p">(</span><span class="n">adding</span><span class="p">)</span>
                    <span class="nf">.add_output</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="k">self</span><span class="p">,</span> <span class="nb">None</span><span class="p">)</span><span class="o">?</span>
                    <span class="nf">.add_output</span><span class="p">(</span><span class="nn">Amount</span><span class="p">::</span><span class="nf">from_sat</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">new</span><span class="p">,</span> <span class="nb">None</span><span class="p">)</span><span class="o">?</span>
                    <span class="nf">.into</span><span class="p">()</span>
            <span class="p">}</span>
            <span class="nn">Proposal</span><span class="p">::</span><span class="n">Payments</span> <span class="p">{</span> <span class="n">payments</span> <span class="p">}</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="k">if</span> <span class="n">payments</span><span class="nf">.is_empty</span><span class="p">()</span> <span class="p">{</span>
                    <span class="k">return</span> <span class="nf">empty</span><span class="p">();</span>
                <span class="p">}</span>
                <span class="c">// collect members with updated balances here</span>
                <span class="k">let</span> <span class="n">spent</span> <span class="o">=</span> <span class="n">payments</span>
                    <span class="nf">.values</span><span class="p">()</span>
                    <span class="nf">.cloned</span><span class="p">()</span>
                    <span class="nf">.map</span><span class="p">(</span><span class="nn">Amount</span><span class="p">::</span><span class="n">from</span><span class="p">)</span>
                    <span class="nf">.fold</span><span class="p">(</span><span class="nn">Amount</span><span class="p">::</span><span class="nf">from_sat</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="p">|</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">|</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="nf">.into</span><span class="p">());</span>
                <span class="k">let</span> <span class="n">balance</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="p">(</span><span class="n">spent</span><span class="nf">.as_btc</span><span class="p">()</span> <span class="o">/</span> <span class="k">self</span><span class="nf">.total</span><span class="p">()</span><span class="nf">.as_btc</span><span class="p">());</span>
                <span class="k">let</span> <span class="k">mut</span> <span class="n">new_members</span> <span class="o">=</span> <span class="k">self</span><span class="py">.members</span><span class="nf">.clone</span><span class="p">();</span>
                <span class="n">new_members</span><span class="nf">.values_mut</span><span class="p">()</span><span class="nf">.for_each</span><span class="p">(|</span><span class="n">m</span><span class="p">|</span> <span class="p">{</span>
                    <span class="n">m</span><span class="py">.relative_votes</span> <span class="o">=</span> <span class="p">(</span><span class="n">m</span><span class="py">.relative_votes</span> <span class="k">as</span> <span class="nb">f64</span> <span class="o">*</span> <span class="n">balance</span><span class="p">)</span><span class="nf">.round</span><span class="p">()</span> <span class="k">as</span> <span class="nb">u64</span><span class="p">;</span>
                <span class="p">});</span>
                <span class="c">// for each payment...</span>
                <span class="c">// Send any leftover funds to a new pool</span>
                <span class="k">let</span> <span class="n">change</span> <span class="o">=</span> <span class="n">Dao</span> <span class="p">{</span>
                    <span class="n">members</span><span class="p">:</span> <span class="n">new_members</span><span class="p">,</span>
                    <span class="n">sequence</span><span class="p">:</span> <span class="k">self</span><span class="py">.sequence</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
                <span class="p">};</span>
                <span class="k">let</span> <span class="k">mut</span> <span class="n">tmpl</span> <span class="o">=</span> <span class="n">ctx</span><span class="nf">.template</span><span class="p">()</span><span class="nf">.add_output</span><span class="p">(</span><span class="n">change</span><span class="nf">.total</span><span class="p">(),</span> <span class="o">&amp;</span><span class="n">change</span><span class="p">,</span> <span class="nb">None</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
                <span class="c">// optional: we could commit to the reason somewhere in metadata </span>
                <span class="c">// e.g. a tapleaf branch... we don't do this here because meh.</span>
                <span class="k">for</span> <span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">amount</span><span class="p">)</span> <span class="n">in</span> <span class="n">payments</span> <span class="p">{</span>
                    <span class="n">tmpl</span> <span class="o">=</span> <span class="n">tmpl</span><span class="nf">.add_output</span><span class="p">(</span><span class="n">amount</span><span class="nf">.try_into</span><span class="p">()</span><span class="o">?</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key</span><span class="p">,</span> <span class="nb">None</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
                <span class="p">}</span>
                <span class="n">tmpl</span><span class="nf">.into</span><span class="p">()</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="nd">REGISTER!</span><span class="p">[</span><span class="n">Dao</span><span class="p">,</span> <span class="s">"logo.png"</span><span class="p">];</span>

</code></pre></div></div>

<p>Lastly, we need some super special sneaky algorithm fun to implement signing authorities
based on majority value. As noted, special uses of FROST could replace this, or future
research on better weighted key protocols.</p>

<p>For now, we limit ourselves to 25 keys so that compilation isn’t too slow. We can afford
having hundreds of thousands or millions of groups because of Taproot :).</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="n">key_groups_to_clause</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">v</span><span class="p">:</span> <span class="o">&amp;</span><span class="p">(</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="p">(</span><span class="n">PublicKey</span><span class="p">,</span> <span class="n">T</span><span class="p">)</span><span class="o">&gt;</span><span class="p">,</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">u32</span><span class="o">&gt;</span><span class="p">))</span> <span class="k">-&gt;</span> <span class="n">Clause</span> <span class="p">{</span>
    <span class="nn">Clause</span><span class="p">::</span><span class="nf">Threshold</span><span class="p">(</span>
        <span class="mi">1</span><span class="p">,</span>
        <span class="n">v</span><span class="na">.1</span><span class="nf">.iter</span><span class="p">()</span>
            <span class="nf">.map</span><span class="p">(|</span><span class="n">m</span><span class="p">|</span> <span class="p">{</span>
                <span class="nn">Clause</span><span class="p">::</span><span class="nf">And</span><span class="p">(</span>
                    <span class="n">v</span><span class="na">.0</span><span class="nf">.iter</span><span class="p">()</span>
                        <span class="nf">.enumerate</span><span class="p">()</span>
                        <span class="nf">.filter_map</span><span class="p">(|(</span><span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="mi">_</span><span class="p">))|</span> <span class="p">{</span>
                            <span class="k">if</span> <span class="n">m</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">i</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
                                <span class="nf">Some</span><span class="p">(</span><span class="n">k</span><span class="nf">.clone</span><span class="p">())</span>
                            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                                <span class="nb">None</span>
                            <span class="p">}</span>
                        <span class="p">})</span>
                        <span class="nf">.map</span><span class="p">(</span><span class="nn">Clause</span><span class="p">::</span><span class="n">Key</span><span class="p">)</span>
                        <span class="nf">.collect</span><span class="p">(),</span>
                <span class="p">)</span>
            <span class="p">})</span>
            <span class="nf">.collect</span><span class="p">(),</span>
    <span class="p">)</span>
<span class="p">}</span>
<span class="k">fn</span> <span class="nf">compute_key_groups</span><span class="p">(</span>
    <span class="n">threshold</span><span class="p">:</span> <span class="nb">u64</span><span class="p">,</span>
    <span class="k">mut</span> <span class="n">el</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="p">(</span><span class="n">PublicKey</span><span class="p">,</span> <span class="nb">u64</span><span class="p">)</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Result</span><span class="o">&lt;</span><span class="p">(</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="p">(</span><span class="n">PublicKey</span><span class="p">,</span> <span class="nb">u64</span><span class="p">)</span><span class="o">&gt;</span><span class="p">,</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">u32</span><span class="o">&gt;</span><span class="p">),</span> <span class="n">CompilationError</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">if</span> <span class="n">el</span><span class="nf">.len</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">25</span> <span class="p">||</span> <span class="n">el</span><span class="nf">.is_empty</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nf">Err</span><span class="p">(</span><span class="nn">CompilationError</span><span class="p">::</span><span class="n">TerminateCompilation</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="c">// sort for stable ordering</span>
    <span class="n">el</span><span class="nf">.sort</span><span class="p">();</span>
    <span class="c">// The bitmasks for which keys to participate</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">sets</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">u32</span><span class="o">&gt;</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[];</span>
    <span class="c">// BEGIN ALGORITHM:</span>
    <span class="c">// if we see a bit set out of range, we can stop.</span>
    <span class="k">let</span> <span class="n">fail_if_set</span> <span class="o">=</span> <span class="p">((</span><span class="o">!</span><span class="mi">0</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">el</span><span class="nf">.len</span><span class="p">())</span> <span class="o">&lt;&lt;</span> <span class="n">el</span><span class="nf">.len</span><span class="p">();</span>
    <span class="c">// we know that 0 elements is invalid, we need up to el.len()</span>
    <span class="k">for</span> <span class="n">i</span> <span class="n">in</span> <span class="mi">1u32</span><span class="o">..=</span><span class="n">el</span><span class="nf">.len</span><span class="p">()</span> <span class="k">as</span> <span class="nb">u32</span> <span class="p">{</span>
        <span class="c">// get the first member of our permutation</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">ct</span> <span class="o">=</span> <span class="nf">element_0</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
        <span class="c">// if any bits are set in the failure zone stop</span>
        <span class="k">while</span> <span class="n">ct</span> <span class="o">&amp;</span> <span class="n">fail_if_set</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
            <span class="c">// compute the sum of the elements in this mask</span>
            <span class="k">let</span> <span class="n">sum</span><span class="p">:</span> <span class="nb">u64</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="o">..</span><span class="n">el</span><span class="nf">.len</span><span class="p">())</span>
                <span class="nf">.map</span><span class="p">(|</span><span class="n">i</span><span class="p">|</span> <span class="k">if</span> <span class="n">ct</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">i</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span> <span class="n">el</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="na">.1</span> <span class="p">}</span> <span class="k">else</span> <span class="p">{</span> <span class="mi">0</span> <span class="p">})</span>
                <span class="py">.sum</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">u64</span><span class="o">&gt;</span><span class="p">();</span>
            <span class="c">// this set is a candidate!</span>
            <span class="k">if</span> <span class="n">sum</span> <span class="o">&gt;=</span> <span class="n">threshold</span> <span class="p">{</span>
                <span class="c">// subtract the smallest value (this is why we sorted) -- if it</span>
                <span class="c">// fails it is not a minimal set because there exists a passing</span>
                <span class="c">// set without this element.</span>
                <span class="c">// note: trailing zeros is guaranteed to be in bounds</span>
                <span class="k">if</span> <span class="n">sum</span> <span class="o">-</span> <span class="n">el</span><span class="p">[</span><span class="n">ct</span><span class="nf">.trailing_zeros</span><span class="p">()</span> <span class="k">as</span> <span class="nb">usize</span><span class="p">]</span><span class="na">.1</span> <span class="o">&lt;</span> <span class="n">threshold</span> <span class="p">{</span>
                    <span class="c">// it did fail, so save it</span>
                    <span class="n">sets</span><span class="nf">.push</span><span class="p">(</span><span class="n">ct</span><span class="p">);</span>
                <span class="p">}</span>
            <span class="p">}</span>
            <span class="c">// get the next ct</span>
            <span class="n">ct</span> <span class="o">=</span> <span class="nf">next_perm</span><span class="p">(</span><span class="n">ct</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="nf">Ok</span><span class="p">((</span><span class="n">el</span><span class="p">,</span> <span class="n">sets</span><span class="p">))</span>
<span class="p">}</span>

<span class="c">/// Adapted from https://www.alexbowe.com/popcount-permutations/</span>
<span class="c">///</span>
<span class="c">/// Compute the lexicographically next bit permutation</span>
<span class="c">/// Taken from http://graphics.stanford.edu/~seander/bithacks.html</span>
<span class="k">fn</span> <span class="nf">next_perm</span><span class="p">(</span><span class="n">v</span><span class="p">:</span> <span class="nb">u32</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">u32</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">t</span><span class="p">:</span> <span class="nb">u32</span> <span class="o">=</span> <span class="n">v</span> <span class="p">|</span> <span class="p">(</span><span class="n">v</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span> <span class="c">// t gets v's least significant 0 bits set to 1</span>
                              <span class="c">// Next set to 1 the most significant bit to change,</span>
                              <span class="c">// set to 0 the least significant ones, and add the necessary 1 bits.</span>
    <span class="k">let</span> <span class="n">w</span><span class="p">:</span> <span class="nb">u32</span> <span class="o">=</span> <span class="p">(</span><span class="n">t</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="p">|</span> <span class="p">(((</span><span class="o">!</span><span class="n">t</span> <span class="o">&amp;</span> <span class="p">(</span><span class="o">!</span><span class="n">t</span><span class="p">)</span><span class="nf">.wrapping_neg</span><span class="p">())</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="n">v</span><span class="nf">.trailing_zeros</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span><span class="p">));</span>
    <span class="n">w</span>
<span class="p">}</span>
<span class="c">///    Generates first permutation with a given amount of set bits, which is</span>
<span class="c">///    used to generate the rest.</span>
<span class="k">fn</span> <span class="nf">element_0</span><span class="p">(</span><span class="n">c</span><span class="p">:</span> <span class="nb">u32</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">u32</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">c</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>All done! Not too bad huh? I think you’re really getting the hang of this thing!</p>

<hr />

<h1 id="using-a-dao">Using a DAO</h1>

<p>Now that we have this DAO we can get together a group of people and share a UTXO.</p>

<p>With that shared balance, we can get everyone in some kind of chat room and ‘govern’
what proposals folks want to vote on.</p>

<p>In particular, I would be very excited to see DAOs emerge for funding Bitcoin
Developers.  This type of structure can potentially help folks communally
allocate capital. Often times the biggest barrier is finding deals that make
sense, and DAOs would enable you to share with a group of friends and they could
make decisions for you.</p>

<p>It would even be possible to create DAOs on behalf of third parties and fund
them. For example, let’s say I get PKs for 10 devs I like and put a 10 BTC into
it and set the shares up so that there is a ‘leader’ with 30%, and the rest
split 70% of voting shares. The leader could just steal the money with another
21%, but would they? I hope not! Instead, they can vote on good things as
intended.  It’d also be possible for the DAO creator to embed an ‘oversight
comittee’ that can yank the funds if not being used.</p>

<p>Minting NFTs is kind of a cool feature since anyone can see they came from the
DAO if they track the DAO’s state updates (conceivably these get published for
auditing). NFTs could be issued as medals of honor for devs who follow their
grants. Or, if you really like NFTs, they could be used to issue software
licenses in exchange for contributing funds to the DAO operators.</p>

<h1 id="does-this-need-ctv">Does this need CTV?</h1>

<p>Nope. Just a fancy multisig, right?</p>

<p>Where CTV is useful is if we want to vote on proposals to put things into CTV
contracts, like subscriptions to developer grants, opening channels, etc.
Imagine the developer gets a contract where they get paid out every week, but
there is a auditing comittee that can be used to terminate the subscription and
return funds to the DAO if misbehavior is detected.</p>

<p>While you don’t need CTV in the DAO backbone, it would help open up new use
cases.</p>

<p>It would also be possible to add some ‘liveness’ smooth degradations of the DAO,
whereby half the majority (e.g., if majority is 50%, 25%) could vote that the
DAO is dead, and after a period of time for the majority recovery, distribute
the funds on a pre-comitted schedule.</p>

<p>We don’t show that here, but it wouldn’t be too hard now would it?</p>

<h1 id="generalizing">Generalizing</h1>

<p>One could go ahead and implement a DAO trait that all DAOs could share and build
a common UX for managing DAOs with a wide variety of custom logic…</p>

<p>It’d also be possible to have a DAO backbone which is a single UTXO, and have
other UTXOs ‘owned’ by the DAO that can get merged in later as a proposal. This
way contributions to the DAO don’t always require a state update from the DAO
itself.</p>

<p>For future work :)</p>
<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:frost" role="doc-endnote">
      <p>FROST allows n-M threshold Schnorr signatures, which can turn into a weighted solution by making M the total value and each party have W amount of keys for their contribution. But this scales poorly because you need to exchange keys and signatures linear in the Amount, which is up to a 51-bit number. <a href="#fnref:frost" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:combo" role="doc-endnote">
      <p>We are going to brute force all the N-N key combinations, so we pick a low number like 24 and things stay ‘small’ enough. <a href="#fnref:combo" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:rat" role="doc-endnote">
      <p>please please if you’re implementing this for real use rational types not floats. <a href="#fnref:rat" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>

  </div>
<hr>
  
<hr>
  <div class="post">
    <h2 class="post-title">
        <a href="/bitcoin/2021/12/21/advent-24/">
        POWSWAP: Oracle Free Bitcoin Hashrate Derivatives
      </a>
  </h2>
  <h4>Day 24: Rubin's Bitcoin Advent Calendar</h4>


    <span class="post-date">21 Dec 2021</span>

    <p><em>Welcome to day 24 of my Bitcoin Advent Calendar. You can see an index of all
the posts <a href="/advent21">here</a> or subscribe at
<a href="https://judica.org/join">judica.org/join</a> to get new posts in your inbox</em></p>

<p>Today’s post is near and dear to my heart – years ago I put up an interest form
for <a href="https://powswap.com">powswap.com</a>, but as I went down the rabbit hole I
realized how badly I wanted generic tooling to automate the building of these
which is partly what led to Sapio!</p>

<p>So therefore it’s very exciting to show you the basics of powswap in Sapio. You
can see how bad the early version was
<a href="https://gist.github.com/JeremyRubin/8bacafdb997c588ef2a203ffeb726b83">here</a>. If
you want to contrast life with Sapio and without.</p>

<h1 id="what-is-a-powswap">What is a Powswap?</h1>

<p>The basic idea of Powswap is super simple. It is a contract that measures a
block surplus or deficit – a Block Delta Contract (BDC). A  BDC allows
counterparties to bet on statements like “at the end of 6 months, we will be +/-
1000 blocks against the current expected number of blocks”, and program a payoff
curve based on the binary outcome of that. The block delta should be – and this
is a matter for the analysts to price on and model – correlated with changes in
hashrate.</p>

<h3 id="who-the-f-cares">WHO THE F CARES</h3>

<p>Well imagine you are about to buy a new fancy mining rig to mine with. But you
have a moment of doubt – what if everyone else is doing that right now too?</p>

<p>You could buy hashrate derivatives where you win money if the hashrate increases
and lose if it stays the same.</p>

<p>This would de-risk your investment in mining.</p>

<p>You can also lever-up and increase profit if you’re adding a lot of hashrate,
doubling down that hashrate goes up, but let’s not entertain the degens shall
we.</p>

<h3 id="ok-ok-how-can-i-do-it">OK OK How can I do it?</h3>

<p>One could imagine making a BDC based on the Oracle system we saw in yesterday’s
post.  But the magic of Powswap is that we will do this without using any oracle
whatsoever, just measuring the blocks directly.</p>

<p>How do we do this?</p>

<p>The answer is actually really simple. Suppose Alice wants to get 1 Bitcoin if
100 blocks are missing at the end of the week (the 28th, let’s say expected 1000
blocks), and Bob wants to win 1 Bitcoin if they are actually there.</p>

<p>All we have to do is have Alice and Bob agree to a multisig to deposit 0.5 BTC
each to, and then pre-sign from it two transactions:</p>

<ol>
  <li>If the date is the 28th at noon and the height is greater than 1000, Bob gets paid 1 BTC</li>
  <li>If the date the date is the 28th at noon + 8 hours, Alice gets paid 1 BTC</li>
</ol>

<p>Let’s think it through:</p>

<p>Suppose that Alice is right and blocks are 100 short by
noon.</p>

<p>In the next 8 hours, only 48 blocks should be mined (and probably less, if the
hashrate has actually decreased).</p>

<p>After that point, Alice has 8 more hours (again, probably more if hashrate
actually decreased) to broadcast and claim her BTC.</p>

<p>Suppose that Bob is right and blocks reach 1000 at noon. Bob has 8 hours to
claim the BTC before Alice can.</p>

<h3 id="metastability">Metastability</h3>

<p>Where this is a bit wonky is that the result is metastable. Let’s assume that
neither Alice nor Bob is right: The deficit is 50 blocks short.</p>

<p>At noon, Bob cannot claim. But in 8 hours he can! But also in 8 hours Alice can
claim too.</p>

<p>So who wins?</p>

<p>The answer is either! Using a POWSWAP you either want to be really right or
really wrong.</p>

<p>We’ll see some cool results around why this might not be a huge deal later.</p>
<hr />

<p>Let’s flip the powswap around now, for a surplus of blocks. Bob thinks the
blocks will be 1000, Alice thinks 1100.</p>

<ol>
  <li>If the date is the 28th at noon + 8 hours, Bob gets paid 1 BTC</li>
  <li>If the date the date is the 28th at noon and there are 1100 blocks, Alice gets paid 1 BTC</li>
</ol>

<p>Under this model if Alice is right there should be that many blocks by that
time, and if Bob is right there should not be and a resaonable amount of time
later Bob can claim.</p>

<hr />

<p>It’s a bit harder to see, but we can even implement this logic more simply as just:</p>

<ol>
  <li>If we reach +1 week, give Bob 1 BTC</li>
  <li>If we reach +1100 blocks, give Alice 1 BTC</li>
</ol>

<p>Then, if a week goes by first without seeing 1100 blocks, Bob can claim. If the
1100 blocks show well before the week is up, then Alice can claim. If neither
are really right then it’s metastable and either could win.</p>

<h2 id="we-are-not-going-there">We are not going there!</h2>

<p>There are a myriad of different combinations of locktimes and heights that you
can use to do this correctly, we won’t focus too much on that in this post, and
we’ll let our contract users decide what parameters they want.  Let the analysts
figure out what the right combo of locktimes and stuff is to hedge different
risks. They should get paid for something, right?</p>

<p>One of the wrinkles is that the less time you have in your contract, the more
metastable it is.  The more time you have, expecially across difficulty
adjustments, the more the deficits can be erased.</p>

<h1 id="implementing-a-powswap">Implementing a Powswap</h1>

<h2 id="is-ctv-required">Is CTV Required?</h2>

<p>In the example I gave above, it is not! However, if you have CTV then one party
can unilaterally open a hashrate derivative for other parties, and that matters
quite a lot!</p>

<p>This means that when we do implement it, we will use <code class="language-plaintext highlighter-rouge">then</code> because if you
want the pre-signature version you can use CTV Emulators.</p>

<hr />

<p>First we’ll start by writing some code to be able to describe the locktimes
under which some outcome is considered “resolved”. We’ll write a container type
(the data we actually need) and then we’ll write a verifier type that makes
for a convenient API for human input. It’s kind of gross, so you can skip
the verifier type code and just imagine you put in the correct parameters.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">/// `ContractVariant` ensures that we either set a Relative Height and Absolute</span>
<span class="c">/// Time or a Relative Time and Absolute Height, the two valid combinations, or</span>
<span class="c">/// just one.</span>
<span class="c">///</span>
<span class="c">/// Note these are unlocking conditions for each participant.</span>
<span class="c">///</span>
<span class="c">/// Validity is ensured through smart constructor</span>
<span class="nd">#[derive(JsonSchema,</span> <span class="nd">Deserialize,</span> <span class="nd">Clone,</span> <span class="nd">Copy)]</span>
<span class="nd">#[serde(try_from</span> <span class="nd">=</span> <span class="s">"ValidContractVariant"</span><span class="nd">)]</span>
<span class="k">pub</span> <span class="k">struct</span> <span class="nf">ContractVariant</span><span class="p">(</span><span class="nb">Option</span><span class="o">&lt;</span><span class="n">AnyRelTimeLock</span><span class="o">&gt;</span><span class="p">,</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">AnyAbsTimeLock</span><span class="o">&gt;</span><span class="p">);</span>

<span class="c">/// In order to test for coherence here, we should convert</span>
<span class="c">/// ValidContractVariant to ContractVariant.</span>
<span class="c">///</span>
<span class="c">/// The coherence rules should match one ruleset of:</span>
<span class="c">/// - a single type of TimeLock (Relative Height, Relative Time, Absolute Time,</span>
<span class="c">///   Absolute Height)</span>
<span class="c">/// - a mixed TimeLock of just Relative Height/Absolute Time or just Relative</span>
<span class="c">///   Time/Absolute Height</span>
<span class="nd">#[derive(JsonSchema,</span> <span class="nd">Deserialize,</span> <span class="nd">Clone)]</span>
<span class="k">struct</span> <span class="nf">ValidContractVariant</span><span class="p">(</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="n">AnyTimeLock</span><span class="o">&gt;</span><span class="p">);</span>

<span class="k">impl</span> <span class="n">TryFrom</span><span class="o">&lt;</span><span class="n">ValidContractVariant</span><span class="o">&gt;</span> <span class="k">for</span> <span class="n">ContractVariant</span> <span class="p">{</span>
    <span class="k">type</span> <span class="n">Error</span> <span class="o">=</span> <span class="n">CompilationError</span><span class="p">;</span>
    <span class="k">fn</span> <span class="nf">try_from</span><span class="p">(</span><span class="n">vcv</span><span class="p">:</span> <span class="n">ValidContractVariant</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Result</span><span class="o">&lt;</span><span class="n">Self</span><span class="p">,</span> <span class="nn">Self</span><span class="p">::</span><span class="n">Error</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">abs</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="mi">_</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">vcv</span>
            <span class="na">.0</span>
            <span class="nf">.iter</span><span class="p">()</span>
            <span class="nf">.filter_map</span><span class="p">(|</span><span class="n">v</span><span class="p">|</span> <span class="p">{</span>
                <span class="k">if</span> <span class="k">let</span> <span class="nn">AnyTimeLock</span><span class="p">::</span><span class="nf">A</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">=</span> <span class="n">v</span> <span class="p">{</span>
                    <span class="nf">Some</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
                <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                    <span class="nb">None</span>
                <span class="p">}</span>
            <span class="p">})</span>
            <span class="nf">.collect</span><span class="p">();</span>
        <span class="k">let</span> <span class="n">rel</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="mi">_</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">vcv</span>
            <span class="na">.0</span>
            <span class="nf">.iter</span><span class="p">()</span>
            <span class="nf">.filter_map</span><span class="p">(|</span><span class="n">v</span><span class="p">|</span> <span class="p">{</span>
                <span class="k">if</span> <span class="k">let</span> <span class="nn">AnyTimeLock</span><span class="p">::</span><span class="nf">R</span><span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="o">=</span> <span class="n">v</span> <span class="p">{</span>
                    <span class="nf">Some</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
                <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                    <span class="nb">None</span>
                <span class="p">}</span>
            <span class="p">})</span>
            <span class="nf">.collect</span><span class="p">();</span>

        <span class="k">let</span> <span class="n">all_rh</span> <span class="o">=</span> <span class="n">rel</span><span class="nf">.iter</span><span class="p">()</span><span class="nf">.all</span><span class="p">(|</span><span class="n">v</span><span class="p">|</span> <span class="nd">matches!</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="nn">AnyRelTimeLock</span><span class="p">::</span><span class="nf">RH</span><span class="p">(</span><span class="n">c</span><span class="p">)));</span>
        <span class="k">let</span> <span class="n">all_rt</span> <span class="o">=</span> <span class="n">rel</span><span class="nf">.iter</span><span class="p">()</span><span class="nf">.all</span><span class="p">(|</span><span class="n">v</span><span class="p">|</span> <span class="nd">matches!</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="nn">AnyRelTimeLock</span><span class="p">::</span><span class="nf">RT</span><span class="p">(</span><span class="n">c</span><span class="p">)));</span>
        <span class="nd">#[derive(Debug)]</span>
        <span class="k">struct</span> <span class="nf">LocalError</span><span class="p">(</span><span class="o">&amp;</span><span class="nv">'static</span> <span class="nb">str</span><span class="p">);</span>
        <span class="k">impl</span> <span class="nn">std</span><span class="p">::</span><span class="nn">fmt</span><span class="p">::</span><span class="n">Display</span> <span class="k">for</span> <span class="n">LocalError</span> <span class="p">{</span>
            <span class="k">fn</span> <span class="nf">fmt</span><span class="p">(</span>
                <span class="o">&amp;</span><span class="k">self</span><span class="p">,</span>
                <span class="n">f</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="nn">std</span><span class="p">::</span><span class="nn">fmt</span><span class="p">::</span><span class="n">Formatter</span><span class="o">&lt;</span><span class="nv">'_</span><span class="o">&gt;</span><span class="p">,</span>
            <span class="p">)</span> <span class="k">-&gt;</span> <span class="nn">std</span><span class="p">::</span><span class="nn">result</span><span class="p">::</span><span class="n">Result</span><span class="o">&lt;</span><span class="p">(),</span> <span class="nn">std</span><span class="p">::</span><span class="nn">fmt</span><span class="p">::</span><span class="n">Error</span><span class="o">&gt;</span> <span class="p">{</span>
                <span class="k">self</span><span class="na">.0</span><span class="nf">.fmt</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">impl</span> <span class="nn">std</span><span class="p">::</span><span class="nn">error</span><span class="p">::</span><span class="n">Error</span> <span class="k">for</span> <span class="n">LocalError</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="o">!</span><span class="p">(</span><span class="n">all_rh</span> <span class="p">||</span> <span class="n">all_rt</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nf">Err</span><span class="p">(</span><span class="nn">CompilationError</span><span class="p">::</span><span class="nf">custom</span><span class="p">(</span><span class="nf">LocalError</span><span class="p">(</span>
                <span class="s">"Must have some timelock set!"</span><span class="p">,</span>
            <span class="p">)));</span>
        <span class="p">}</span>
        <span class="k">let</span> <span class="n">all_ah</span> <span class="o">=</span> <span class="n">abs</span><span class="nf">.iter</span><span class="p">()</span><span class="nf">.all</span><span class="p">(|</span><span class="n">v</span><span class="p">|</span> <span class="nd">matches!</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="nn">AnyAbsTimeLock</span><span class="p">::</span><span class="nf">AH</span><span class="p">(</span><span class="n">c</span><span class="p">)));</span>
        <span class="k">let</span> <span class="n">all_at</span> <span class="o">=</span> <span class="n">abs</span><span class="nf">.iter</span><span class="p">()</span><span class="nf">.all</span><span class="p">(|</span><span class="n">v</span><span class="p">|</span> <span class="nd">matches!</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="nn">AnyAbsTimeLock</span><span class="p">::</span><span class="nf">AT</span><span class="p">(</span><span class="n">c</span><span class="p">)));</span>
        <span class="k">if</span> <span class="o">!</span><span class="p">(</span><span class="n">all_ah</span> <span class="p">||</span> <span class="n">all_at</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nf">Err</span><span class="p">(</span><span class="nn">CompilationError</span><span class="p">::</span><span class="nf">custom</span><span class="p">(</span><span class="nf">LocalError</span><span class="p">(</span>
                <span class="s">"Incoherent Absolute Timelocks (mixed height/time)"</span><span class="p">,</span>
            <span class="p">)));</span>
        <span class="p">}</span>

        <span class="k">let</span> <span class="n">relative</span> <span class="o">=</span> <span class="n">rel</span><span class="nf">.iter</span><span class="p">()</span><span class="nf">.max_by_key</span><span class="p">(|</span><span class="n">v</span><span class="p">|</span> <span class="nn">AnyRelTimeLock</span><span class="p">::</span><span class="nf">get</span><span class="p">(</span><span class="n">v</span><span class="p">))</span><span class="nf">.cloned</span><span class="p">();</span>
        <span class="k">let</span> <span class="n">absolute</span> <span class="o">=</span> <span class="n">abs</span><span class="nf">.iter</span><span class="p">()</span><span class="nf">.max_by_key</span><span class="p">(|</span><span class="n">v</span><span class="p">|</span> <span class="nn">AnyAbsTimeLock</span><span class="p">::</span><span class="nf">get</span><span class="p">(</span><span class="n">v</span><span class="p">))</span><span class="nf">.cloned</span><span class="p">();</span>

        <span class="k">if</span> <span class="nd">matches!</span><span class="p">((</span><span class="n">relative</span><span class="p">,</span> <span class="n">absolute</span><span class="p">),</span> <span class="p">(</span><span class="nb">None</span><span class="p">,</span> <span class="nb">None</span><span class="p">))</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nf">Err</span><span class="p">(</span><span class="nn">CompilationError</span><span class="p">::</span><span class="nf">custom</span><span class="p">(</span><span class="nf">LocalError</span><span class="p">(</span>
                <span class="s">"Must have some timelock set!"</span><span class="p">,</span>
            <span class="p">)));</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">all_rt</span> <span class="o">&amp;&amp;</span> <span class="n">all_at</span><span class="p">)</span> <span class="p">||</span> <span class="p">(</span><span class="n">all_rh</span> <span class="o">&amp;&amp;</span> <span class="n">all_rt</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nf">Err</span><span class="p">(</span><span class="nn">CompilationError</span><span class="p">::</span><span class="nf">custom</span><span class="p">(</span><span class="nf">LocalError</span><span class="p">(</span>
                <span class="s">"Must mix {Relative,Absolute} Height and Absolute time!"</span><span class="p">,</span>
            <span class="p">)));</span>
        <span class="p">}</span>
        <span class="nf">Ok</span><span class="p">(</span><span class="nf">ContractVariant</span><span class="p">(</span><span class="n">relative</span><span class="nf">.cloned</span><span class="p">(),</span> <span class="n">absolute</span><span class="nf">.cloned</span><span class="p">()))</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="k">impl</span> <span class="n">ContractVariant</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">get_relative</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">AnyRelTimeLock</span> <span class="p">{</span>
        <span class="k">self</span><span class="na">.0</span><span class="nf">.unwrap_or</span><span class="p">(</span><span class="nn">RelTime</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="nf">.into</span><span class="p">())</span>
    <span class="p">}</span>
    <span class="k">fn</span> <span class="nf">get_abs</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">AnyAbsTimeLock</span> <span class="p">{</span>
        <span class="k">self</span><span class="na">.1</span><span class="nf">.unwrap_or</span><span class="p">(</span><span class="nn">AbsHeight</span><span class="p">::</span><span class="nf">try_from</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="nf">.unwrap</span><span class="p">()</span><span class="nf">.into</span><span class="p">())</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>With that out of the way, let’s now define our contract data:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">/// Instructions for a Payment from an outcome</span>
<span class="nd">#[derive(JsonSchema,</span> <span class="nd">Deserialize,</span> <span class="nd">Clone)]</span>
<span class="k">pub</span> <span class="k">struct</span> <span class="n">Pays</span> <span class="p">{</span>
    <span class="n">sats</span><span class="p">:</span> <span class="n">AmountU64</span><span class="p">,</span>
    <span class="n">to</span><span class="p">:</span> <span class="n">PublicKey</span><span class="p">,</span>
<span class="p">}</span>
<span class="c">/// A `Outcome` is a contract where</span>
<span class="nd">#[derive(JsonSchema,</span> <span class="nd">Deserialize,</span> <span class="nd">Clone)]</span>
<span class="k">pub</span> <span class="k">struct</span> <span class="n">Outcome</span> <span class="p">{</span>
    <span class="c">/// # Variant</span>
    <span class="c">/// if the base is time or height for the relative leg.</span>
    <span class="n">unlocks_if</span><span class="p">:</span> <span class="n">ContractVariant</span><span class="p">,</span>
    <span class="c">/// # Outcome</span>
    <span class="c">/// Payments to make (should be &gt;= 1)</span>
    <span class="n">outcome</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">Pays</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">}</span>
<span class="c">/// A `PowSwap` is a contract where</span>
<span class="nd">#[derive(JsonSchema,</span> <span class="nd">Deserialize,</span> <span class="nd">Clone)]</span>
<span class="k">pub</span> <span class="k">struct</span> <span class="n">PowSwap</span> <span class="p">{</span>
    <span class="c">/// # Parties</span>
    <span class="k">pub</span> <span class="n">outcomes</span><span class="p">:</span> <span class="p">[</span><span class="n">Outcome</span><span class="p">;</span> <span class="mi">2</span><span class="p">],</span>
    <span class="c">/// # Cooperate Key</span>
    <span class="n">coop</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">PublicKey</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">}</span>
<span class="k">impl</span> <span class="n">Contract</span> <span class="k">for</span> <span class="n">PowSwap</span> <span class="p">{</span>
    <span class="nd">declare!</span> <span class="p">{</span><span class="n">then</span><span class="p">,</span> <span class="nn">Self</span><span class="p">::</span><span class="n">payoff</span><span class="p">}</span>
    <span class="nd">declare!</span> <span class="p">{</span><span class="n">finish</span><span class="p">,</span> <span class="nn">Self</span><span class="p">::</span><span class="n">cooperate</span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<p>As you can see, it’s pretty simple. We just need a set of keys to ‘opt out’ of
the on-chain execution, and a set of outcomes and their unlocking conditions.
We can pay an arbitrary number of parties.</p>

<p>Now to finish, let’s implement the logic. It’s really simple, we just create the
(2) transactions and assign the sequences/locktimes properly.</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span> <span class="n">PowSwap</span> <span class="p">{</span>
    <span class="nd">#[guard]</span>
    <span class="k">fn</span> <span class="nf">cooperate</span><span class="p">(</span><span class="k">self</span><span class="p">,</span> <span class="n">ctx</span><span class="p">:</span> <span class="n">Context</span><span class="p">)</span> <span class="p">{</span>
        <span class="nn">Clause</span><span class="p">::</span><span class="nf">And</span><span class="p">(</span><span class="k">self</span><span class="py">.coop</span><span class="nf">.iter</span><span class="p">()</span><span class="nf">.cloned</span><span class="p">()</span><span class="nf">.map</span><span class="p">(</span><span class="nn">Clause</span><span class="p">::</span><span class="n">Key</span><span class="p">)</span><span class="nf">.collect</span><span class="p">())</span>
    <span class="p">}</span>
    <span class="k">fn</span> <span class="nf">make_payoffs</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">ctx</span><span class="p">:</span> <span class="n">Context</span><span class="p">,</span> <span class="n">payments</span><span class="p">:</span> <span class="o">&amp;</span><span class="p">[</span><span class="n">Pays</span><span class="p">])</span> <span class="k">-&gt;</span> <span class="n">Result</span><span class="o">&lt;</span><span class="n">Builder</span><span class="p">,</span> <span class="n">CompilationError</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">bld</span> <span class="o">=</span> <span class="n">ctx</span><span class="nf">.template</span><span class="p">();</span>
        <span class="k">for</span> <span class="n">Pays</span> <span class="p">{</span> <span class="n">sats</span><span class="p">,</span> <span class="n">to</span> <span class="p">}</span> <span class="n">in</span> <span class="n">payments</span> <span class="p">{</span>
            <span class="n">bld</span> <span class="o">=</span> <span class="n">bld</span><span class="nf">.add_output</span><span class="p">(</span><span class="n">sats</span><span class="nf">.clone</span><span class="p">()</span><span class="nf">.into</span><span class="p">(),</span> <span class="n">to</span><span class="p">,</span> <span class="nb">None</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="nf">Ok</span><span class="p">(</span><span class="n">bld</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="nd">#[then]</span>
    <span class="k">fn</span> <span class="nf">payoff</span><span class="p">(</span><span class="k">self</span><span class="p">,</span> <span class="k">mut</span> <span class="n">base_ctx</span><span class="p">:</span> <span class="n">Context</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">ret</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">Result</span><span class="o">&lt;</span><span class="n">Template</span><span class="p">,</span> <span class="mi">_</span><span class="o">&gt;&gt;</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[];</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">path</span><span class="p">)</span> <span class="n">in</span> <span class="k">self</span><span class="py">.outcomes</span><span class="nf">.iter</span><span class="p">()</span><span class="nf">.enumerate</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">ctx</span> <span class="o">=</span> <span class="n">base_ctx</span><span class="nf">.derive_num</span><span class="p">(</span><span class="n">i</span> <span class="k">as</span> <span class="nb">u64</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
            <span class="k">let</span> <span class="n">v</span> <span class="o">=</span> <span class="k">self</span>
                <span class="nf">.make_payoffs</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">path</span><span class="py">.outcome</span><span class="p">)</span><span class="o">?</span>
                <span class="nf">.set_sequence</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">path</span><span class="py">.unlocks_if</span><span class="nf">.get_relative</span><span class="p">())</span><span class="o">?</span>
                <span class="nf">.set_lock_time</span><span class="p">(</span><span class="n">path</span><span class="py">.unlocks_if</span><span class="nf">.get_abs</span><span class="p">())</span><span class="o">?</span>
                <span class="nf">.into</span><span class="p">();</span>
            <span class="n">ret</span><span class="nf">.push</span><span class="p">(</span><span class="nf">Ok</span><span class="p">(</span><span class="n">v</span><span class="p">));</span>
        <span class="p">}</span>
        <span class="nf">Ok</span><span class="p">(</span><span class="nn">Box</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">ret</span><span class="nf">.into_iter</span><span class="p">()))</span>
    <span class="p">}</span>
<span class="p">}</span>

</code></pre></div></div>

<p>That wasn’t so bad now, was it?</p>

<h1 id="using-powswap">Using PowSwap</h1>

<p>We already said we’re not going to analyze the profit of these contracts, but I
want to give a couple cool ways to use these.</p>

<h2 id="when-to-cooperate">When to Cooperate?</h2>

<p>One thing that I think would be important to settling a hashrate derivative would be
to set it for, say, 6 months forecast and then try to roll the strategy at 3 months cooperatively.</p>

<p>This way you don’t have trouble with metastability as you and your counterparty
can update forecasts and re-enter the contract, or go separate ways.</p>

<h2 id="take-it-to-the-limit">TAKE IT TO THE LIMIT</h2>

<p>Well what if instead of settling on-chain, you nested these in LN channels? And
then every microsecond you don’t see a block being advertised and broadcast, you
update your probabilities and try to adjust with your counterparty. It becomes
pretty neat becuase you essentially make a hashrate perpetual where if your
counterparty dies then you settle on-chain (if they’re really dead, you just
win), but you can update your forecasts on whatever frequency you want. All
trustlessly.</p>

<h3 id="the-information-market-for-relaying">The Information Market for Relaying</h3>

<p>This opens the door for HFT-ing information about the rate of block production.
Knowing a block is mined and getting it relayed to you before your counterparty
gives you an edge in trading.</p>

<p>Maybe this pays for really really good block relaying infrastructure?</p>

<h2 id="galaxy-brain-me">GALAXY BRAIN ME</h2>

<p>Hey, it’s me. Your old friend Decentralized Coordination Free Mining Pools. What
if we made – using CTV – the channels/payouts by default resolve into some sort
of hashrate future, and we had an automated hedging market maker that could incorporate
your desired side of a trade from old hash shares into opening new positions for you every block.
If it was in channels you could immediately turn these into hashrate perps.</p>

<h3 id="metastability-1">Metastability</h3>
<p>If you’re a miner and you mine, say, 2 blocks a day, then you can usually expect
to be able to settle your own metastable hashrate derivatives as long as the
metastable window isn’t smaller than ~12 hours. This means that while normie
pleb users might struggle with closing their derivatives, miner-to-miner
hashrate derivatives should be actually pretty safe if you stay in your
bounds.</p>

<hr />

<p>Can we really do this? How effective is it? Honestly I have no idea I just think
it’s mind-blowing.</p>

<h2 id="gimme-all-my-options">Gimme all My Options</h2>

<p>This idea composes beautifully with the options we saw yesterday. What if I want
the <em>option</em> for the next week to open up a 6 month hashrate contract with you?</p>

<p>Just toss it into an Expiring Under Funded Option contract and you got it. And
because we represented these as Dutch Auctionable NFTs, you can advertise the
position you’re willing to open to the network and take the best offer for this
option.</p>

<p>Sapio composes. Legit forreal.</p>

<p>DeFi is coming to Bitcoin.</p>

<p>And it’s going to help with securing the base layer of Bitcoin by permitting
trustless financialization of investments in hashrate.</p>

<hr />

<p>Have a great day. P.s. now is a good time to join
<a href="https://utxos.org/signals">utxos.org/signals</a> if you think CTV is a great next
step in Bitcoin Development’s journey.</p>


  </div>
<hr>
  
</div>

<div class="pagination">
  
    <a class="pagination-item newer" href="/blog/">Newer</a>
  
  
  <a class="pagination-item older" href="/blog/page/3/">Older</a>
  
</div>

</div>

        </div>
        <div class="content container" style="padding-bottom:0;padding-top:0;bottom:0px;">
            <div class="posts" style="height:14pt;margin-bottom:0;">
                <div class="post">
                    <p style="text-align:center;font-size:12pt;">&copy; 2011-2021 Jeremy Rubin. All rights reserved.</p>
                </div>
            </div>
        </div>
    </body>
</html>
